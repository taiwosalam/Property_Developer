"use client";

import { useEffect, useRef, useState } from "react";
import { createPortal } from "react-dom";
import { cn } from "@/lib/utils";
import { SuccessProgressIcon, WarningProgressIcon } from "@/public/icons/icons";

export interface ProgressCardStep {
  title: string;
  desc: string;
  type: "warning" | "success";
}

interface ProgressCardLoaderProps {
  loading: boolean;
  steps: ProgressCardStep[];
  className?: string;
  onClose?: () => void;
}

const ProgressCardLoader = ({
  loading,
  steps,
  className,
  onClose,
}: ProgressCardLoaderProps) => {
  const [mounted, setMounted] = useState(false);
  const [currentStep, setCurrentStep] = useState(0);
  const [visible, setVisible] = useState(false);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    setMounted(true);
    return () => setMounted(false);
  }, []);

  // Handle step progression
  //   useEffect(() => {
  //     if (!mounted) return;

  //     if (loading) {
  //       setVisible(true);
  //       setCurrentStep(0);

  //       const stepDuration = 2000; // ms per step while loading
  //       intervalRef.current = setInterval(() => {
  //         setCurrentStep((prev) => {
  //           const maxIndexWhileLoading = steps.length - 2; // stop at second-to-last
  //           if (prev < maxIndexWhileLoading) {
  //             return prev + 1;
  //           }
  //           return prev; // hold at second-to-last until loading ends
  //         });
  //       }, stepDuration);
  //     } else {
  //       // stop slow interval
  //       if (intervalRef.current) clearInterval(intervalRef.current);

  //       // if we haven't reached the second-to-last step yet, fast-forward steps
  //       if (currentStep < steps.length - 1) {
  //         let stepIndex = currentStep;
  //         const fastInterval = setInterval(() => {
  //           stepIndex++;
  //           setCurrentStep(stepIndex);
  //           if (stepIndex >= steps.length - 1) {
  //             clearInterval(fastInterval);
  //             setTimeout(() => setVisible(false), 500); // close after .5s
  //           }
  //         }, 200); // 0.2s per step
  //       } else {
  //         // already at last step
  //         setTimeout(() => setVisible(false), 1500);
  //       }
  //     }

  //     return () => {
  //       if (intervalRef.current) clearInterval(intervalRef.current);
  //     };
  //   }, [loading, mounted, steps.length, currentStep]);

  // Handle step progression
  useEffect(() => {
    if (!mounted) return;

    if (loading) {
      setVisible(true);
      setCurrentStep(0);

      const stepDuration = 2000; // ms per step while loading
      intervalRef.current = setInterval(() => {
        setCurrentStep((prev) => {
          const maxIndexWhileLoading = steps.length - 2; // stop at second-to-last
          if (prev < maxIndexWhileLoading) {
            return prev + 1;
          }
          return prev; // hold at second-to-last until loading ends
        });
      }, stepDuration);
    } else {
      // Stop any existing interval
      if (intervalRef.current) clearInterval(intervalRef.current);

      // If not at the last step, speed up to show all remaining steps
      if (currentStep < steps.length - 1) {
        const fastStepDuration = 200; // 0.2s per step
        intervalRef.current = setInterval(() => {
          setCurrentStep((prev) => {
            if (prev < steps.length - 1) {
              return prev + 1;
            }
            // Reached the last step, stop interval and hide after a short delay
            if (intervalRef.current) clearInterval(intervalRef.current);
            setTimeout(() => setVisible(false), 500); // Close 0.5s after last step
            return prev;
          });
        }, fastStepDuration);
      } else {
        // Already at the last step, just hide after a short delay
        setTimeout(() => setVisible(false), 500);
      }
    }

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, [loading, mounted, steps.length, currentStep]);

  
  if (!mounted || !visible) return null;
  const target = typeof document !== "undefined" ? document.body : null;
  if (!target) return null;

  const step = steps[currentStep];
  const isSuccess = step?.type === "success";

  return createPortal(
    <div className="fixed inset-0 z-[99999] bg-black/40 backdrop-blur-sm flex items-center justify-center p-4">
      <div
        className={cn(
          "bg-white rounded-2xl shadow-lg w-[70%] sm:w-1/2 p-6 flex flex-col items-center gap-4 text-center",
          className
        )}
      >
        {isSuccess ? (
          <SuccessProgressIcon
            percentage={Math.round(((currentStep + 1) / steps.length) * 100)}
          />
        ) : (
          <WarningProgressIcon
            percentage={Math.round(((currentStep + 1) / steps.length) * 100)}
          />
        )}

        {/* TEXT CONTENTS */}
        <div className="flex flex-col gap-2">
          <h2 className="text-md font-semibold">{step?.title}</h2>
          <p className="text-sm font-normal">→ {step.desc}</p>
        </div>

        {/* PROGRESS */}
        <div className="w-full bg-gray-200 h-2 rounded-full overflow-hidden">
          <div
            className={cn(
              "h-2 transition-all duration-500 ease-out",
              isSuccess ? "bg-green-500" : "bg-yellow-500"
            )}
            style={{ width: `${((currentStep + 1) / steps.length) * 100}%` }}
          />
        </div>

        {onClose && (
          <button
            onClick={onClose}
            className="absolute top-4 right-4 py-1 px-2 rounded-full bg-gray-100 hover:bg-gray-200 text-gray-600"
          >
            ×
          </button>
        )}
      </div>
    </div>,
    target
  );
};

export default ProgressCardLoader;
