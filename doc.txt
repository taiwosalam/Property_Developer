// import { KeyValueListProps } from "./types";
// import clsx from "clsx";

// export const KeyValueList = <T extends object>({
//   styles,
//   data = {},
//   chunkSize = 3,
//   referenceObject,
//   direction = "row",
//   truncateLength, // Add truncateLength prop
// }: KeyValueListProps<T>) => {
//   const keys = Object.keys(referenceObject) as Array<keyof T>;

//   // Helper function to truncate text
//   const truncateText = (text: string, length?: number): string => {
//     if (length === undefined || text.length <= length) {
//       return text;
//     }
//     return text.slice(0, length) + "...";
//   };

//   const chunkArray = (arr: Array<keyof T>, size: number) =>
//     arr.reduce(
//       (acc, _, i) => (i % size === 0 ? [...acc, arr.slice(i, i + size)] : acc),
//       [] as Array<Array<keyof T>>
//     );

//   const chunkedKeys = chunkArray(keys, chunkSize);

//   return (
//     <>
//       {chunkedKeys.map((chunk, chunkIndex) => (
//         <div
//           key={chunkIndex}
//           className={clsx("flex-1 text-base font-medium capitalize", {
//             "flex gap-10": direction === "row",
//             "custom-flex-col gap-6": direction === "column",
//           })}
//         >
//           {direction === "column" ? (
//             <>
//               {chunk.map((key) => (
//                 <div
//                   key={`${chunkIndex}-${String(key)}`}
//                   className="custom-flex-col gap-2"
//                 >
//                   <p
//                     className="text-[#747474] dark:text-darkText-1 whitespace-nowrap"
//                     style={styles?.[key]?.label}
//                   >
//                     {String(key).split("_").join(" ")}
//                   </p>
//                   <p
//                     className="text-black dark:text-darkText-2 line-clamp-1"
//                     style={styles?.[key]?.value}
//                   >
//                     {/* Apply truncation to the value */}
//                     {data && data[key] !== undefined
//                       ? truncateText(String(data[key]), truncateLength)
//                       : "---"}
//                   </p>
//                 </div>
//               ))}
//             </>
//           ) : (
//             <>
//               <div className="custom-flex-col gap-4">
//                 {chunk.map((key) => (
//                   <p
//                     key={`${chunkIndex}-${String(key)}`}
//                     className="text-[#747474] dark:text-darkText-1 whitespace-nowrap"
//                     style={styles?.[key]?.label}
//                   >
//                     {String(key).split("_").join(" ")}
//                   </p>
//                 ))}
//               </div>
//               <div className="custom-flex-col gap-4">
//                 {chunk.map((key) => (
//                   <p
//                     key={`${chunkIndex}-${String(key)}`}
//                     className="text-black dark:text-darkText-2"
//                     style={styles?.[key]?.value}
//                   >
//                     {/* Apply truncation to the value */}
//                     {data && data[key] !== undefined
//                       ? truncateText(String(data[key]), truncateLength)
//                       : "---"}
//                   </p>
//                 ))}
//               </div>
//             </>
//           )}
//         </div>
//       ))}
//     </>
//   );
// };

// export default KeyValueList;











// "use client";

// import "keen-slider/keen-slider.min.css";
// import { ChevronLeft, ThumbsDown, ThumbsUp } from "@/public/icons/icons";
// import { useRouter, useParams } from "next/navigation";
// import Button from "@/components/Form/Button/button";
// import { ContributorDetails } from "@/components/Community/Contributor";
// import CompanySummary from "@/components/Community/CompanySummary";
// import useFetch from "@/hooks/useFetch";
// import { useState, useEffect, useMemo } from "react";
// import PropertyRequestComments from "@/components/Community/PropertyRequestComments";
// import useRefetchOnEvent from "@/hooks/useRefetchOnEvent";
// import MoreDetailsCard from "@/components/AgentRequest/moreDetails";
// import ThreadArticle from "@/components/AgentRequest/threadArticle";
// import PageCircleLoader from "@/components/Loader/PageCircleLoader";
// import { transformPropertyRequestResponse } from "./data";
// import NetworkError from "@/components/Error/NetworkError";
// import ServerError from "@/components/Error/ServerError";

// interface PropertyRequestResponse {
//   data: {
//     PropertyRequest: any;
//     contributor: any;
//     readByData: any;
//     comments: any;
//     company_summary: any;
//   };
// }

// const PreviewPage = () => {
//   const router = useRouter();
//   const { requestId } = useParams();
//   // const [propertyRequest, setPropertyRequest] = useState<any>(null);
//   const [user, setUser] = useState<any>(null);
//   const [readByData, setReadByData] = useState<any>(null);
//   // const [companySummary, setCompanySummary] = useState<any>(null);
//   // const [comments, setComments] = useState<any>(null);
//   // const [comments, setComments] = useState<any>(null);
//   const [slug, setSlug] = useState<string>("");
//   const {
//     data,
//     loading,
//     error,
//     isNetworkError,
//     refetch: refetchComments,
//   } = useFetch<PropertyRequestResponse>(`/agent_-requests/${requestId}`);
//   useRefetchOnEvent("refetchComments", () => refetchComments({ silent: true }));

//   // useEffect(() => {
//   //   if (data) {
//   //     setPropertyRequest(data.data.PropertyRequest);
//   //     setSlug(data.data.PropertyRequest.slug);
//   //     setUser(data.data.contributor);
//   //     setReadByData(data.data.readByData);
//   //     setComments(data.data.comments);
//   //     setCompanySummary(data.data.company_summary);
//   //   }
//   // }, [data]);

//   const transformedData = useMemo(
//     () => transformPropertyRequestResponse(data),
//     [data]
//   );

//   const { propertyRequest, contributor, companySummary, comments } = transformedData;

//   console.log("data here - ", data);

//   if (loading) return <PageCircleLoader />;
//   if (isNetworkError) return <NetworkError />;
//   if (error) return <ServerError error={error} />;
//   if (!transformedData) return <div className="text-center text-text-secondary">No data available</div>;

//   return (
//     <div>
//       <div className="flex items-center justify-between flex-wrap gap-2 mb-4">
//         <div className="flex items-center gap-1 mb-1">
//           <button
//             type="button"
//             aria-label="Go Back"
//             onClick={() => router.back()}
//             className="p-2"
//           >
//             <ChevronLeft />
//           </button>
//           <h1 className="text-black dark:text-white font-bold text-lg lg:text-xl">
//             {propertyRequest?.title}
//           </h1>
//         </div>
//         <Button
//           href={`/management/agent-request/my-properties-request/create`}
//           size="sm"
//           className="py-2 px-3"
//         >
//           Create Property Request
//         </Button>
//       </div>
//       <div className="flex flex-col gap-y-5 gap-x-10 lg:flex-row lg:items-start">
//         <div className="lg:w-[58%] lg:max-h-screen lg:overflow-y-auto custom-round-scrollbar lg:pr-2">
//           <MoreDetailsCard propertyRequest={propertyRequest} user={user} />
//           <ThreadArticle
//             propertyRequest={propertyRequest}
//             comments={data?.data.comments}
//           />
//           <PropertyRequestComments
//             id={requestId as string}
//             slug={slug}
//             comments={data?.data.comments}
//             // setComments={setComments}
//           />
//         </div>
//         <div className="lg:flex-1 space-y-5 lg:max-h-screen lg:overflow-y-auto custom-round-scrollbar lg:pr-2">
//           <ContributorDetails
//             title="Requester Details"
//             contributors={user}
//             post={propertyRequest}
//             // targetAudience={propertyRequest?.target_audience?.join(", ")}
//             postedDate={propertyRequest?.createdAt}
//             updatedDate={propertyRequest?.updatedAt}
//           />
//           <CompanySummary companySummary={companySummary} />
//         </div>
//       </div>
//     </div>
//   );
// };

// export default PreviewPage;










// import { RefObject } from "react";
// import html2canvas from "html2canvas";
// import jsPDF from "jspdf";

// const useExport = (
//   firstPageRef?: RefObject<HTMLDivElement>,
//   restOfContentRef?: RefObject<HTMLDivElement>,
//   printRef?: RefObject<HTMLDivElement>
// ) => {
//   const handlePrint = async () => {

//     const pdf = new jsPDF();
//     const pdfPageWidth = pdf.internal.pageSize.getWidth();
//     const pdfPageHeight = pdf.internal.pageSize.getHeight();

//     // if (printRef && printRef.current) {
//     //   printRef.current.style.transform = "scale(1.2)";
//     //   printRef.current.style.transformOrigin = "top left";
//     // }

//     // Define padding in millimeters and convert to points
//     const desiredPaddingMM = 10;
//     const pointsPerMM = 72 / 25.4;
//     const desiredPaddingPoints = desiredPaddingMM * pointsPerMM;

//     // Calculate content area dimensions
//     const contentWidthInPoints = pdfPageWidth - 2 * desiredPaddingPoints;
//     const contentHeightInPoints = pdfPageHeight - 2 * desiredPaddingPoints;

//     if (printRef && printRef.current) {
//       // Use printRef to capture all content as a single unit
//       const printCanvas = await html2canvas(printRef.current, {
//         backgroundColor: null,
//         scale: 2,
//         useCORS: true,
//       });
//       const printWidth = printCanvas.width;
//       const printHeight = printCanvas.height;

//       // Calculate page height in pixels for the entire content
//       const pageHeightInPixels =
//         (contentHeightInPoints / contentWidthInPoints) * printWidth;
//       const numPages = Math.ceil(printHeight / pageHeightInPixels);

//       for (let page = 0; page < numPages; page++) {
//         const startY = page * pageHeightInPixels;
//         const endY = Math.min(startY + pageHeightInPixels, printHeight);
//         const pageCanvas = document.createElement("canvas");
//         pageCanvas.width = printWidth;
//         pageCanvas.height = endY - startY;
//         const pageCtx = pageCanvas.getContext("2d")!;
//         pageCtx.drawImage(
//           printCanvas,
//           0,
//           startY,
//           printWidth,
//           endY - startY,
//           0,
//           0,
//           printWidth,
//           endY - startY
//         );

//         const imageWidthInPoints = contentWidthInPoints;
//         const imageHeightInPoints =
//           (pageCanvas.height / pageCanvas.width) * imageWidthInPoints;

//         if (page > 0) {
//           pdf.addPage();
//         }
//         pdf.addImage(
//           pageCanvas.toDataURL("image/png"),
//           "PNG",
//           desiredPaddingPoints,
//           desiredPaddingPoints,
//           imageWidthInPoints,
//           imageHeightInPoints
//         );
//       }
//     } else if (
//       firstPageRef &&
//       firstPageRef.current &&
//       restOfContentRef &&
//       restOfContentRef.current
//     ) {
//       // Original behavior with firstPageRef and restOfContentRef
//       // First page
//       const firstPageCanvas = await html2canvas(firstPageRef.current);
//       const imageWidthInPoints = contentWidthInPoints;
//       const imageHeightInPoints =
//         (firstPageCanvas.height / firstPageCanvas.width) * imageWidthInPoints;
//       pdf.addImage(
//         firstPageCanvas.toDataURL("image/png"),
//         "PNG",
//         desiredPaddingPoints,
//         desiredPaddingPoints,
//         imageWidthInPoints,
//         imageHeightInPoints
//       );

//       // Rest of the content
//       const restOfContentCanvas = await html2canvas(restOfContentRef.current);
//       const restOfContentWidth = restOfContentCanvas.width;
//       const restOfContentHeight = restOfContentCanvas.height;

//       const pageHeightInPixels =
//         (contentHeightInPoints / contentWidthInPoints) * restOfContentWidth;
//       const numPages = Math.ceil(restOfContentHeight / pageHeightInPixels);

//       for (let page = 0; page < numPages; page++) {
//         const startY = page * pageHeightInPixels;
//         const endY = Math.min(startY + pageHeightInPixels, restOfContentHeight);
//         const pageCanvas = document.createElement("canvas");
//         pageCanvas.width = restOfContentWidth;
//         pageCanvas.height = endY - startY;
//         const pageCtx = pageCanvas.getContext("2d")!;
//         pageCtx.drawImage(
//           restOfContentCanvas,
//           0,
//           startY,
//           restOfContentWidth,
//           endY - startY,
//           0,
//           0,
//           restOfContentWidth,
//           endY - startY
//         );

//         const imageHeightInPoints =
//           (pageCanvas.height / pageCanvas.width) * imageWidthInPoints;

//         pdf.addPage();
//         pdf.addImage(
//           pageCanvas.toDataURL("image/png"),
//           "PNG",
//           desiredPaddingPoints,
//           desiredPaddingPoints,
//           imageWidthInPoints,
//           imageHeightInPoints
//         );
//       }
//     } else {
//       console.error("Required refs are not set");
//       return;
//     }

//     // Generate PDF as blob and trigger print
//     const pdfData = pdf.output("blob");
//     const pdfUrl = URL.createObjectURL(pdfData);
//     const printWindow = window.open(pdfUrl);
//     if (printWindow) {
//       setTimeout(() => {
//         printWindow.print();
//       }, 1000); // Wait for PDF to load
//     }
//   };

//   const handleDownload = async () => {
//     const pdf = new jsPDF();
//     const pdfPageWidth = pdf.internal.pageSize.getWidth();
//     const pdfPageHeight = pdf.internal.pageSize.getHeight();

//     // Define padding in millimeters and convert to points
//     const desiredPaddingMM = 10;
//     const pointsPerMM = 72 / 25.4;
//     const desiredPaddingPoints = desiredPaddingMM * pointsPerMM;

//     // Calculate content area dimensions
//     const contentWidthInPoints = pdfPageWidth - 2 * desiredPaddingPoints;
//     const contentHeightInPoints = pdfPageHeight - 2 * desiredPaddingPoints;

//     if (printRef && printRef.current) {
//       // Use printRef to capture all content as a single unit
//       const printCanvas = await html2canvas(printRef.current);
//       const printWidth = printCanvas.width;
//       const printHeight = printCanvas.height;

//       // Calculate page height in pixels for the entire content
//       const pageHeightInPixels =
//         (contentHeightInPoints / contentWidthInPoints) * printWidth;
//       const numPages = Math.ceil(printHeight / pageHeightInPixels);

//       for (let page = 0; page < numPages; page++) {
//         const startY = page * pageHeightInPixels;
//         const endY = Math.min(startY + pageHeightInPixels, printHeight);
//         const pageCanvas = document.createElement("canvas");
//         pageCanvas.width = printWidth;
//         pageCanvas.height = endY - startY;
//         const pageCtx = pageCanvas.getContext("2d")!;
//         pageCtx.drawImage(
//           printCanvas,
//           0,
//           startY,
//           printWidth,
//           endY - startY,
//           0,
//           0,
//           printWidth,
//           endY - startY
//         );

//         const imageWidthInPoints = contentWidthInPoints;
//         const imageHeightInPoints =
//           (pageCanvas.height / pageCanvas.width) * imageWidthInPoints;

//         if (page > 0) {
//           pdf.addPage();
//         }
//         pdf.addImage(
//           pageCanvas.toDataURL("image/png"),
//           "PNG",
//           desiredPaddingPoints,
//           desiredPaddingPoints,
//           imageWidthInPoints,
//           imageHeightInPoints
//         );
//       }
//     } else if (
//       firstPageRef &&
//       firstPageRef.current &&
//       restOfContentRef &&
//       restOfContentRef.current
//     ) {
//       // Original behavior with firstPageRef and restOfContentRef
//       // First page
//       const firstPageCanvas = await html2canvas(firstPageRef.current);
//       const imageWidthInPoints = contentWidthInPoints;
//       const imageHeightInPoints =
//         (firstPageCanvas.height / firstPageCanvas.width) * imageWidthInPoints;
//       pdf.addImage(
//         firstPageCanvas.toDataURL("image/png"),
//         "PNG",
//         desiredPaddingPoints,
//         desiredPaddingPoints,
//         imageWidthInPoints,
//         imageHeightInPoints
//       );

//       // Rest of the content
//       const restOfContentCanvas = await html2canvas(restOfContentRef.current);
//       const restOfContentWidth = restOfContentCanvas.width;
//       const restOfContentHeight = restOfContentCanvas.height;

//       const pageHeightInPixels =
//         (contentHeightInPoints / contentWidthInPoints) * restOfContentWidth;
//       const numPages = Math.ceil(restOfContentHeight / pageHeightInPixels);

//       for (let page = 0; page < numPages; page++) {
//         const startY = page * pageHeightInPixels;
//         const endY = Math.min(startY + pageHeightInPixels, restOfContentHeight);
//         const pageCanvas = document.createElement("canvas");
//         pageCanvas.width = restOfContentWidth;
//         pageCanvas.height = endY - startY;
//         const pageCtx = pageCanvas.getContext("2d")!;
//         pageCtx.drawImage(
//           restOfContentCanvas,
//           0,
//           startY,
//           restOfContentWidth,
//           endY - startY,
//           0,
//           0,
//           restOfContentWidth,
//           endY - startY
//         );

//         const imageHeightInPoints =
//           (pageCanvas.height / pageCanvas.width) * imageWidthInPoints;

//         pdf.addPage();
//         pdf.addImage(
//           pageCanvas.toDataURL("image/png"),
//           "PNG",
//           desiredPaddingPoints,
//           desiredPaddingPoints,
//           imageWidthInPoints,
//           imageHeightInPoints
//         );
//       }
//     } else {
//       console.error("Required refs are not set");
//       return;
//     }

//     pdf.save("report.pdf");
//   };

//   return { handlePrint, handleDownload };
// };

// export default useExport;

// hooks/useExport.ts








      // StartRent.tsx
import { useRef } from "react";
import { AgreementPreview } from "@/components/Modal/tenant-document";

const StartRent = () => {
  const agreementRef = useRef<HTMLDivElement>(null);
  // ... other state and hooks ...

  const handleStartRent = async () => {
    // ... validation logic ...

    let doc_file: File | null = null;
    if (!IS_WEB_TENANT) {
      try {
        setPdfLoading(true);
        if (agreementRef.current) {
          const canvas = await html2canvas(agreementRef.current, { scale: 2 });
          const pdf = new jsPDF();
          const imageWidthInPoints = pdf.internal.pageSize.getWidth() - 20;
          const imageHeightInPoints = (canvas.height / canvas.width) * imageWidthInPoints;
          pdf.addImage(
            canvas.toDataURL("image/png"),
            "PNG",
            10,
            10,
            imageWidthInPoints,
            imageHeightInPoints
          );
          const pdfBlob = pdf.output("blob");
          doc_file = new File([pdfBlob], `agreement_${unit_data.unit_id}.pdf`, {
            type: "application/pdf",
          });
        } else {
          toast.error("Failed to generate agreement PDF.");
          return;
        }
      } catch (err) {
        console.error("PDF generation error:", err);
        toast.error("Failed to generate agreement PDF.");
        return;
      } finally {
        setPdfLoading(false);
      }
    }

    // ... FormData and API call ...
  };

  return (
    <div className="space-y-6 pb-[100px]">
      {/* Hidden AgreementPreview */}
      <div style={{ display: "none" }} ref={agreementRef}>
        <AgreementPreview renderUI={false} />
      </div>
      {/* ... rest of the component ... */}
    </div>
  );
};







  const handleStartRent = async () => {
    if (!unit_data?.unit_id || !selectedTenantId) {
      toast.error(
        `Missing required information: Unit or ${
          isRental ? "Tenant" : "Occupant"
        } not selected.`
      );
      return;
    }

    if (!selectedCheckboxOptions) {
      toast.error("Notification preferences not set.");
      return;
    }

    // Validate dueDate
    if (dueDate && dueDate.isBefore(dayjs(), "day")) {
      toast.warning("End date cannot be in the past.");
      return;
    }
    const successMsg = isRental
      ? "Rent Started Succesfully"
      : "Occupant Moved In Successfully";
    const failedMsg = isRental
      ? "Failed to start Rent, Try Again!"
      : "Failed to Move Occupant In, Try Again!";

    const IS_WEB_TENANT =
      selectedOccupant?.userTag?.toLocaleLowerCase() === "web";

    let doc_file: File | null = null;
    if (!IS_WEB_TENANT) {
      try {
        setPdfLoading(true);
        // Debug: Log documentData to inspect its structure
        console.log("documentData:", documentData);
        const agreementData: AgreementData = {
          documentData,
          unitName,
          isLoading: agreementLoading,
          error: agreementError,
        };
        const pdfBlob = await generateAgreementPDF(agreementData);
        if (pdfBlob) {
          doc_file = new File([pdfBlob], `agreement_${unit_data.unit_id}.pdf`, {
            type: "application/pdf",
          });
        } else {
          toast.error(
            "Failed to generate agreement PDF due to missing or invalid data."
          );
          return;
        }
      } catch (err) {
        console.error("PDF generation error:", err);
        toast.error("Failed to generate agreement PDF.");
        return;
      } finally {
        setPdfLoading(false);
      }
    }
    console.log("doc_file", doc_file);
    // const payload = {
    //   unit_id: unit_data.unit_id,
    //   tenant_id: selectedTenantId,
    //   start_date: startDate,
    //   payment_type: "full",
    //   rent_type: "new",
    //   mobile_notification: selectedCheckboxOptions.mobile_notification ? 1 : 0,
    //   email_alert: selectedCheckboxOptions.email_alert ? 1 : 0,
    //   has_invoice: selectedCheckboxOptions.create_invoice ? 1 : 0,
    // };
    // try {
    //   setReqLoading(true);
    //   const res = await startRent(payload);
    //   if (res) {
    //     toast.success(successMsg);
    //     router.push("/management/rent-unit");
    //   }
    // } catch (err) {
    //   toast.error(failedMsg);
    // } finally {
    //   setReqLoading(false);
    // }
  };




      {/* HIDDEN DOCUMENT FOR MOBILE TENANT/OCCUPANTS */}
      <div style={{ display: "none", width: "800px" }} ref={agreementRef}>
        <AgreementPreview renderUI={false} />
      </div>
















    
      let doc_file: File | null = null;
      if (!IS_WEB_TENANT) {
        try {
          setPdfLoading(true);
          // Debug: Log documentData to inspect its structure
          console.log("documentData:", documentData);
          const agreementData: AgreementData = {
            documentData,
            unitName,
            isLoading: agreementLoading,
            error: agreementError,
          };
          const pdfBlob = await generateAgreementPDF(agreementData);
          if (pdfBlob) {
            doc_file = new File([pdfBlob], `agreement_${unit_data.unit_id}.pdf`, {
              type: "application/pdf",
            });
          } else {
            toast.error("Failed to generate agreement PDF due to missing or invalid data.");
            return;
          }
        } catch (err) {
          console.error("PDF generation error:", err);
          toast.error("Failed to generate agreement PDF.");
          return;
        } finally {
          setPdfLoading(false);
        }
      }
    console.log("doc_file", doc_file);













      "use client";

import React, { useRef } from "react";
import { toast } from "sonner";
import { useRouter } from "next/navigation";
import {
  Parties,
  PropertyDescription,
  AttorneyInfo,
  LawFirmInfo,
  Attestation,
  ClauseList,
  WitnessSignatureDate,
} from "@/app/(nav)/documents/preview/component";
import {
  witnessLandlord,
  witnessTenant,
  witness,
} from "@/app/(nav)/documents/preview/data";
import { DocumentPreviewData } from "@/app/(nav)/documents/preview/types";
import Button from "../Form/Button/button";
import { useAgreementData } from "@/hooks/useAgreementData";
import { useAgreementExport } from "@/hooks/useAgreementExport";

interface AgreementPreviewProps {
  onClose?: () => void; // Optional callback for closing modal
  renderUI?: boolean; // Prop to toggle UI elements
}

export const AgreementPreview = ({
  onClose,
  renderUI = true,
}: AgreementPreviewProps) => {
  const router = useRouter();
  const firstPageRef = useRef<HTMLDivElement>(null);
  const restOfContentRef = useRef<HTMLDivElement>(null);

  // Fetch and transform agreement data
  const { documentData, unitName, isLoading, error } = useAgreementData();

  // Handle export functionality (used in modal UI)
  const { handleDownload, isDownloading } = useAgreementExport({
    firstPageRef,
    restOfContentRef,
  });

  // Handle errors
  if (error) {
    toast.error(error);
    if (onClose) {
      onClose();
    } else {
      router.back();
    }
    return null;
  }

  // Show loading state
  if (isLoading || !documentData) {
    return (
      <div className="text-center text-gray-600 dark:text-gray-400 py-4">
        Loading agreement...
      </div>
    );
  }

  const {
    parties,
    propertyDescription,
    attorney,
    lawFirm,
    attestation,
    witnessLawFirm,
    clauses,
  } = documentData;

  const content = (
    <div className="agreement-preview-content">
      <div ref={firstPageRef} className="agreement-preview-first-page">
        <Parties landlord={parties.landlord} tenant={parties.tenant} />
        <div className="agreement-preview-section">
          <PropertyDescription description={propertyDescription} />
          <AttorneyInfo attorney={attorney} />
        </div>
        <LawFirmInfo lawFirm={lawFirm} />
      </div>
      <div ref={restOfContentRef}>
        <Attestation
          date={attestation.date}
          landlord={attestation.landlord}
          tenant={attestation.tenant}
        />
        <ClauseList clauses={clauses} />
        <WitnessSignatureDate
          landlord={witnessLandlord}
          tenant={witnessTenant}
          witness={witness}
          lawFirm={witnessLawFirm}
        />
      </div>
    </div>
  );

  if (!renderUI) {
    return content;
  }

  return (
    <div className="agreement-preview-container">
      <div className="agreement-preview-header">
        {onClose && (
          <Button
            type="button"
            onClick={onClose}
            size="custom"
            className="agreement-preview-close-button"
            variant="sky_blue"
            aria-label="Close modal"
          >
            Close
          </Button>
        )}
      </div>
      {content}
      <div className="agreement-preview-footer">
        <Button
          type="button"
          onClick={() => handleDownload(unitName)}
          size="custom"
          className="agreement-preview-download-button"
          variant="sky_blue"
          disabled={isDownloading}
          aria-label="Download agreement"
        >
          {isDownloading ? "Downloading..." : "Download"}
        </Button>
      </div>
    </div>
  );
};


















// "use client";

// import React, { useRef } from "react";
// import { toast } from "sonner";
// import { useRouter } from "next/navigation";
// import {
//   Parties,
//   PropertyDescription,
//   AttorneyInfo,
//   LawFirmInfo,
//   Attestation,
//   ClauseList,
//   WitnessSignatureDate,
// } from "@/app/(nav)/documents/preview/component";
// import {
//   witnessLandlord,
//   witnessTenant,
//   witness,
// } from "@/app/(nav)/documents/preview/data";
// import { DocumentPreviewData } from "@/app/(nav)/documents/preview/types";
// import Button from "../Form/Button/button";
// import { useAgreementData } from "@/hooks/useAgreementData";
// import { useAgreementExport } from "@/hooks/useAgreementExport";

// interface AgreementPreviewProps {
//   onClose?: () => void; // Optional callback for closing modal
// }

// export const AgreementPreview = ({ onClose }: AgreementPreviewProps) => {
//   const router = useRouter();
//   const firstPageRef = useRef<HTMLDivElement>(null);
//   const restOfContentRef = useRef<HTMLDivElement>(null);

//   // Fetch and transform agreement data
//   const { documentData, unitName, isLoading, error } = useAgreementData();

//   // Handle export functionality
//   const { handleDownload, isDownloading } = useAgreementExport({
//     firstPageRef,
//     restOfContentRef,
//   });

//   // Handle errors
//   if (error) {
//     toast.error(error);
//     if (onClose) {
//       onClose();
//     } else {
//       router.back();
//     }
//     return null;
//   }

//   // Show loading state
//   if (isLoading || !documentData) {
//     return (
//       <div className="text-center text-gray-600 dark:text-gray-400 py-4">
//         Loading agreement...
//       </div>
//     );
//   }

//   const {
//     parties,
//     propertyDescription,
//     attorney,
//     lawFirm,
//     attestation,
//     witnessLawFirm,
//     clauses,
//   } = documentData;

//   return (
//     <div className="agreement-preview-container">
//       <div className="agreement-preview-header">
//         {onClose && (
//           <Button
//             type="button"
//             onClick={onClose}
//             size="custom"
//             className="agreement-preview-close-button"
//             variant="sky_blue"
//             aria-label="Close modal"
//           >
//             Close
//           </Button>
//         )}
//       </div>
//       <div className="agreement-preview-content">
//         <div ref={firstPageRef} className="agreement-preview-first-page">
//           <Parties landlord={parties.landlord} tenant={parties.tenant} />
//           <div className="agreement-preview-section">
//             <PropertyDescription description={propertyDescription} />
//             <AttorneyInfo attorney={attorney} />
//           </div>
//           <LawFirmInfo lawFirm={lawFirm} />
//         </div>
//         <div ref={restOfContentRef}>
//           <Attestation
//             date={attestation.date}
//             landlord={attestation.landlord}
//             tenant={attestation.tenant}
//           />
//           <ClauseList clauses={clauses} />
//           <WitnessSignatureDate
//             landlord={witnessLandlord}
//             tenant={witnessTenant}
//             witness={witness}
//             lawFirm={witnessLawFirm}
//           />
//         </div>
//       </div>
//       <div className="agreement-preview-footer">
//         <Button
//           type="button"
//           onClick={() => handleDownload(unitName)}
//           size="custom"
//           className="agreement-preview-download-button"
//           variant="sky_blue"
//           disabled={isDownloading}
//           aria-label="Download agreement"
//         >
//           {isDownloading ? "Downloading..." : "Download"}
//         </Button>
//       </div>
//     </div>
//   );
// };
