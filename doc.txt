
// import { KeyValueListProps } from "./types";
// import clsx from "clsx";

// export const KeyValueList = <T extends object>({
//   styles,
//   data = {},
//   chunkSize = 3,
//   referenceObject,
//   direction = "row",
//   truncateLength, // Add truncateLength prop
// }: KeyValueListProps<T>) => {
//   const keys = Object.keys(referenceObject) as Array<keyof T>;

//   // Helper function to truncate text
//   const truncateText = (text: string, length?: number): string => {
//     if (length === undefined || text.length <= length) {
//       return text;
//     }
//     return text.slice(0, length) + "...";
//   };

//   const chunkArray = (arr: Array<keyof T>, size: number) =>
//     arr.reduce(
//       (acc, _, i) => (i % size === 0 ? [...acc, arr.slice(i, i + size)] : acc),
//       [] as Array<Array<keyof T>>
//     );

//   const chunkedKeys = chunkArray(keys, chunkSize);

//   return (
//     <>
//       {chunkedKeys.map((chunk, chunkIndex) => (
//         <div
//           key={chunkIndex}
//           className={clsx("flex-1 text-base font-medium capitalize", {
//             "flex gap-10": direction === "row",
//             "custom-flex-col gap-6": direction === "column",
//           })}
//         >
//           {direction === "column" ? (
//             <>
//               {chunk.map((key) => (
//                 <div
//                   key={`${chunkIndex}-${String(key)}`}
//                   className="custom-flex-col gap-2"
//                 >
//                   <p
//                     className="text-[#747474] dark:text-darkText-1 whitespace-nowrap"
//                     style={styles?.[key]?.label}
//                   >
//                     {String(key).split("_").join(" ")}
//                   </p>
//                   <p
//                     className="text-black dark:text-darkText-2 line-clamp-1"
//                     style={styles?.[key]?.value}
//                   >
//                     {/* Apply truncation to the value */}
//                     {data && data[key] !== undefined
//                       ? truncateText(String(data[key]), truncateLength)
//                       : "---"}
//                   </p>
//                 </div>
//               ))}
//             </>
//           ) : (
//             <>
//               <div className="custom-flex-col gap-4">
//                 {chunk.map((key) => (
//                   <p
//                     key={`${chunkIndex}-${String(key)}`}
//                     className="text-[#747474] dark:text-darkText-1 whitespace-nowrap"
//                     style={styles?.[key]?.label}
//                   >
//                     {String(key).split("_").join(" ")}
//                   </p>
//                 ))}
//               </div>
//               <div className="custom-flex-col gap-4">
//                 {chunk.map((key) => (
//                   <p
//                     key={`${chunkIndex}-${String(key)}`}
//                     className="text-black dark:text-darkText-2"
//                     style={styles?.[key]?.value}
//                   >
//                     {/* Apply truncation to the value */}
//                     {data && data[key] !== undefined
//                       ? truncateText(String(data[key]), truncateLength)
//                       : "---"}
//                   </p>
//                 ))}
//               </div>
//             </>
//           )}
//         </div>
//       ))}
//     </>
//   );
// };

// export default KeyValueList;



















"use client";

import { useParams, useRouter } from "next/navigation";
import { useCallback, useEffect, useState } from "react";
import { useChatStore } from "@/store/message";
import { groupMessagesByDay } from "../data";
import Picture from "@/components/Picture/picture";
import Messages from "@/components/Message/messages";
import { empty } from "@/app/config";
import { UsersProps } from "../types";
import ChatSkeleton from "@/components/Skeleton/chatSkeleton";
import { useAuthStore } from "@/store/authStore";
import Link from "next/link";
import useConversationListener from "@/hooks/useConversationListen";
import api from "@/services/api";
import { useGlobalStore } from "@/store/general-store";

interface Message {
  id: number;
  text: string | null;
  senderId: number;
  timestamp: string;
  content_type: string;
}

const Chat = () => {
  const router = useRouter();
  const { data, setChatData } = useChatStore();
  const { id } = useParams<{ id: string }>();
  const user_id = useAuthStore((state) => state.user_id);
  const users = data?.users?.users || [];
  const messageUserData = useGlobalStore((s) => s.messageUserData);
  const store_messages = data?.conversations || [];
  const [conversations, setConversations] = useState<any[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [conversationId, setConversationId] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);

  const fetchMessages = useCallback(async () => {
    try {
      setError(null);
      const response = await api.get(`/messages/conversations/user/${id}`);
      if (response.data.status === "success") {
        const mappedMessages: Message[] = response.data.messages.map(
          (msg: any) => ({
            id: msg.id,
            text: msg.content ?? null,
            senderId: msg.sender_id,
            timestamp: msg.updated_at || new Date().toISOString(),
            content_type: msg.content_type,
          })
        );
        setChatData("conversations", mappedMessages);
        // Assume API returns conversation ID (adjust based on actual response)
        setConversationId(response.data.conversation?.id?.toString() || null);
      } else {
        setError("Failed to load messages.");
      }
    } catch (error: any) {
      console.error("API error:", error.message);
      setError("Failed to load messages. Please try again.");
    } finally {
      setIsLoading(false);
    }
  }, [id, setChatData]);

  const handleNewMessage = useCallback(
    (newMessage: Message) => {
      const exists = store_messages.some(
        (msg: any) => msg.id === newMessage.id
      );
      if (!exists) {
        const updatedConversations = [...store_messages, newMessage].sort(
          (a, b) =>
            new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
        );
        setChatData("conversations", updatedConversations);
      }
    },
    [store_messages, setChatData]
  );

  useEffect(() => {
    if (!id) {
      setIsLoading(false);
      return;
    }

    setIsLoading(true);
    fetchMessages();

    return () => {
      setConversations([]);
      setChatData("conversations", []);
      setConversationId(null);
    };
  }, [id, fetchMessages, setChatData]);

  useEffect(() => {
    if (store_messages.length > 0) {
      const groupedMessages = groupMessagesByDay(store_messages);
      setConversations(groupedMessages);
    }
  }, [store_messages]);

  useConversationListener(
    id,
    conversationId,
    handleNewMessage,
    (error: any) => {
      console.error("Pusher failed:", error);
      setError(
        "Real-time updates unavailable. Messages may not update automatically."
      );
    }
  );

  const userId = Number(id);
  const user =
    messageUserData || users.find((u: UsersProps) => Number(u.id) === userId);

  if (!user) {
    router.replace("/messages");
    return null;
  }

  if (isLoading) {
    return <ChatSkeleton />;
  }

  return (
    <>
      <div className="py-4 px-6 bg-neutral-2 dark:bg-black">
        <div className="flex items-center gap-3">
          <button onClick={() => router.push("/messages")}>
            <Picture src="/icons/chevron-left.svg" alt="back" size={20} />
          </button>
          <Link
            href={`/management/staff-branch/${user.branch_id}/branch-staff/${user?.staff_id}`}
            className="flex items-center gap-4 text-left"
          >
            <Picture
              src={user?.imageUrl || empty}
              alt="profile picture"
              containerClassName="custom-secondary-bg rounded-full"
              size={32}
              rounded
              status={false}
            />
            <div className="custom-flex-col">
              <p className="text-text-primary dark:text-white text-base font-medium capitalize">
                {user?.name}
              </p>
              <p className="text-text-disabled dark:text-darkText-2 text-[10px] font-normal">
                Tap here for contact info
              </p>
            </div>
          </Link>
        </div>
      </div>
      <div className="py-5 px-6 flex-1 overflow-auto custom-round-scrollbar bg-white dark:bg-black custom-flex-col gap-8">
        {error && <div className="text-red-500 text-center p-2">{error}</div>}
        {conversations.length > 0 &&
          conversations.map((group, index) => (
            <Messages
              key={index}
              day={group.day}
              messages={group.messages}
              userId={user_id as string}
            />
          ))}
      </div>
    </>
  );
};

export default Chat;






  // Handlers
  // const handleRenewRent = async () => {
  //   if (!unitData?.unit_id || !unitData?.occupant?.id) {
  //     toast.warning(
  //       "Missing required information: unit or occupant not found."
  //     );
  //     return;
  //   }
  //   if (!selectedCheckboxOptions) {
  //     toast.warning("Notification preferences not set.");
  //     return;
  //   }
  //   if (!startDate) {
  //     toast.warning("Start date is required.");
  //     return;
  //   }
  //   if (dueDate && dueDate.isBefore(dayjs(startDate), "day")) {
  //     toast.warning("Due date cannot be before the start date.");
  //     return;
  //   }

  //   // If rent_agreement is true, open the agreement preview modal
  //   if (selectedCheckboxOptions.rent_agreement) {
  //     setIsAgreementModalOpen(true);
  //     return;
  //   }

  //   // If rent_agreement is false, proceed directly
  //   await submitRent(null);
  // };

  // const submitRent = async (doc_file: File | null) => {
  //   const successMsg = isRental
  //     ? "Rent Renewed Successfully"
  //     : "Fee Renewed Successfully";
  //   const failedMsg = isRental ? "Failed to renew rent" : "Failed to renew fee";

  //   const payloadObj = {
  //     unit_id: unitData.unit_id,
  //     tenant_id: unitData.occupant.id,
  //     start_date: dayjs(startDate).format("MM/DD/YYYY"),
  //     payment_type: "full",
  //     rent_type: "renew",
  //     mobile_notification: selectedCheckboxOptions.mobile_notification ? 1 : 0,
  //     email_alert: selectedCheckboxOptions.email_alert ? 1 : 0,
  //     has_invoice: selectedCheckboxOptions.create_invoice ? 1 : 0,
  //     sms_alert: selectedCheckboxOptions.sms_alert ? 1 : 0,
  //     has_penalty: penaltyAmount > 0 ? 1 : 0,
  //     penalty_amount: penaltyAmount > 0 ? penaltyAmount : 0,
  //     has_document: doc_file ? 1 : 0,
  //     ...(doc_file && { doc_file }),
  //   };

  //   const payload = objectToFormData(payloadObj);

  //   try {
  //     setReqLoading(true);
  //     const res = await startRent(payload);
  //     if (res) {
  //       toast.success(successMsg);
  //       router.push("/management/rent-unit");
  //     }
  //   } catch (err) {
  //     toast.error(failedMsg);
  //   } finally {
  //     setReqLoading(false);
  //     setIsAgreementModalOpen(false);
  //   }
  // };


  // useEffect(() => {
  //   if (usersMessages) {
  //     const transformed = transformUsersMessages(usersMessages).filter(
  //       (msg) => msg.id !== loggedInUserId
  //     );
  //     setPageUsersMsg(transformed);
  //     setChatData("users_messages", transformed);
  //   }
  // }, [usersMessages]);

  // useEffect(() => {
  //   if (usersData) {
  //     setChatData("users", transformCompanyUsersData(usersData));
  //   }
  // }, [usersData]);

















"use client";

import { useParams, useRouter } from "next/navigation";
import { useCallback, useEffect, useState } from "react";
import { useChatStore } from "@/store/message";
import { groupMessagesByDay } from "../data"; // The new grouping helper
import Picture from "@/components/Picture/picture";
import Messages from "@/components/Message/messages";
import { empty } from "@/app/config";
import { UsersProps } from "../types";
import ChatSkeleton from "@/components/Skeleton/chatSkeleton";
import { useAuthStore } from "@/store/authStore";
import { getLocalStorage } from "@/utils/local-storage";
import Link from "next/link";
import useConversationListener from "@/hooks/useConversationListen";
import api from "@/services/api";
import { useGlobalStore } from "@/store/general-store";

interface Message {
  id: number;
  text: string | null;
  senderId: number;
  timestamp: string;
  content_type: string;
}

const Chat = () => {
  const router = useRouter();
  const { data, setChatData } = useChatStore();
  const { id } = useParams<{ id: string }>();
  const user_id = useAuthStore((state) => state.user_id);
  const users = data?.users?.users || [];
  const messageUserData = useGlobalStore((s) => s.messageUserData);
  const store_messages = data?.conversations || [];
  const [conversations, setConversations] = useState<any[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isPusherFailed, setIsPusherFailed] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Fetch messages from API
  const fetchMessages = useCallback(async () => {
    try {
      setError(null);
      const response = await api.get(`/messages/conversations/user/${id}`);
      console.log("API response:", response.data);
      if (response.data.status === "success") {
        const mappedMessages: Message[] = response.data.messages.map(
          (msg: any) => ({
            id: msg.id,
            text: msg.content ?? null,
            senderId: msg.sender_id,
            // timestamp: `${msg.date} ${msg.timestamp}`,
            timestamp: `${msg.updated_at} ${msg.timestamp}`,
            content_type: msg.content_type,
          })
        );
        setChatData("conversations", mappedMessages);
      } else {
        setError("Failed to load messages.");
      }
    } catch (error: any) {
      console.error("API error:", error.response?.data || error.message);
      setError("Failed to load messages. Please try again later.");
    } finally {
      setIsLoading(false);
    }
  }, [id, setChatData]);

  // Handle new Pusher messages
  const handleNewMessage = useCallback(
    (newMessage: Message) => {
      const updatedConversations = [...store_messages, newMessage].sort(
        (a, b) => a.id - b.id
      );
      setChatData("conversations", updatedConversations);
    },
    [store_messages, setChatData]
  );

  // Initialize Pusher and fetch messages
  useEffect(() => {
    if (!id) {
      setIsLoading(false);
      return;
    }

    setIsLoading(true);
    setConversations([]);
    setChatData("conversations", []);
    fetchMessages();

    return () => {
      setConversations([]);
      setChatData("conversations", []);
    };
  }, [id, fetchMessages, setChatData]);

  // Polling when Pusher fails
  useEffect(() => {
    let pollingInterval: NodeJS.Timeout | null = null;

    if (isPusherFailed) {
      console.log("Pusher failed, switching to polling every 30 seconds...");
      pollingInterval = setInterval(() => {
        fetchMessages();
      }, 30000);
    }

    return () => {
      if (pollingInterval) {
        console.log("Stopping polling...");
        clearInterval(pollingInterval);
      }
    };
  }, [isPusherFailed, fetchMessages]);

  // Update grouped conversations when messages change
  useEffect(() => {
    if (store_messages.length > 0) {
      const groupedMessages = groupMessagesByDay(store_messages);
      setConversations(groupedMessages);
    }
  }, [store_messages]);

  // Pusher subscription
  useConversationListener(id, handleNewMessage, (error: any) => {
    console.error("Pusher connection failed:", error);
    setIsPusherFailed(true);
  });

  // Find user
  const userId = Number(id);
  const user = messageUserData || users.find((u: UsersProps) => Number(u.id) === Number(userId));

  if (!user) {
    router.replace("/messages");
    return null;
  }

  if (isLoading) {
    return <ChatSkeleton />;
  }

  return (
    <>
      <div className="py-4 px-6 bg-neutral-2 dark:bg-black">
        <div className="flex items-center gap-3">
          <button onClick={() => router.push("/messages")}>
            <Picture src="/icons/chevron-left.svg" alt="back" size={20} />
          </button>
          <Link
            href={`/management/staff-branch/${user.branch_id}/branch-staff/${user?.staff_id}`}
            className="flex items-center gap-4 text-left"
          >
            <Picture
              src={user?.imageUrl || empty}
              alt="profile picture"
              containerClassName="custom-secondary-bg rounded-full"
              size={32}
              rounded
              status={false}
            />
            <div className="custom-flex-col">
              <p className="text-text-primary dark:text-white text-base font-medium capitalize">
                {user?.name}
              </p>
              <p className="text-text-disabled dark:text-darkText-2 text-[10px] font-normal">
                Tap here for contact info
              </p>
            </div>
          </Link>
        </div>
      </div>
      <div className="py-5 px-6 flex-1 overflow-auto custom-round-scrollbar bg-white dark:bg-black custom-flex-col gap-8">
      {error && (
          <div className="text-red-500 text-center p-2">{error}</div>
        )}
        {conversations.length > 0 &&
          conversations.map((group, index) => (
            <Messages
              key={index}
              day={group.day}
              messages={group.messages}
              userId={user_id as string}
            />
          ))}
      </div>
    </>
  );
};

export default Chat;














// import { useState, useEffect, useMemo } from "react";
// import { RentSectionTitle } from "../rent-section-container";
// import { FeeDetails } from "../rent-section-container";
// import { FeeDetail } from "../types";
// import { currencySymbols } from "@/utils/number-formatter";
// import { useRenewRentContext } from "@/utils/renew-rent-context";
// import { calculateOverduePeriods } from "@/app/(nav)/management/rent-unit/[id]/renew-rent/data";
// import { calculateOwingAmountAndPeriods, getOwingFeeDetails } from "./data";
// import { calculateRentPenalty } from "@/app/(nav)/management/rent-unit/data";
// import { useOccupantStore } from "@/hooks/occupant-store";
// import { RentPeriod } from "../data";

// const OwingFee = ({ show = false }: { show?: boolean }) => {
//   const { isRental, unitData, currency, due_date, start_date, isUpfrontPaymentChecked } =
//     useRenewRentContext();

//   console.log("unitDaya", unitData);
//   console.log("due_date", due_date);
//   // Zustand store
//   const { penaltyAmount, setPenaltyAmount, setOverduePeriods, overduePeriods } = useOccupantStore();
//   const [owingAmount, setOwingAmount] = useState<number>(0);
//   // const [overduePeriods, setOverduePeriods] = useState<number>(0);

//   const chargePenalty = unitData.chargePenalty;
//   // const chargePenalty = true; //TODO: UNCOMMENT THE TOP
//   const rent_penalty_setting = unitData.rent_penalty_setting;
//   const feePeriod = unitData.fee_period;
//   const rentAmount = Number(unitData.fee_amount);
//   const renewalTenantTotalPrice = Number(unitData.renewalTenantTotalPrice) || 0;

//   console.log("overduePeriods", overduePeriods)

//   // useEffect(() => {
//   //   if (due_date && unitData.fee_period && renewalTenantTotalPrice > 0) {

//   //     // Calculate owing amount and periods
//   //     const { overduePeriods, owingAmount } = calculateOwingAmountAndPeriods({
//   //       start_date,
//   //       due_date,
//   //       feePeriod: feePeriod as RentPeriod,
//   //       renewalTenantTotalPrice,
//   //     });

//   //     // Calculate penalty amount
//   //     const periods = calculateOverduePeriods(
//   //       due_date,
//   //       unitData.fee_period as any
//   //     );
//   //     const calculatedOwing =
//   //       periods * Number(unitData.renewalTenantTotalPrice);

//   //     const penaltyAmount = calculateRentPenalty(
//   //       chargePenalty,
//   //       rent_penalty_setting,
//   //       rentAmount,
//   //       feePeriod as any,
//   //       periods
//   //     );
//   //     setPenaltyAmount(penaltyAmount);
//   //     setOwingAmount(calculatedOwing);
//   //     // setOverduePeriods(periods);
//   //     setOverduePeriods(overduePeriods);
//   //   }
//   // }, [
//   //   due_date,
//   //   unitData.fee_period,
//   //   unitData.renewalTenantTotalPrice,
//   //   chargePenalty,
//   //   rent_penalty_setting,
//   //   rentAmount,
//   //   feePeriod,
//   //   setPenaltyAmount,
//   // ]);

//   useEffect(() => {
//     if (start_date && due_date && feePeriod && renewalTenantTotalPrice > 0) {
//       // Calculate owing amount and periods
//       const { overduePeriods, owingAmount } = calculateOwingAmountAndPeriods({
//         start_date,
//         due_date,
//         feePeriod: feePeriod as RentPeriod,
//         renewalTenantTotalPrice,
//       });

//       // Keep existing penalty calculation
//       const calculatedPenalty = calculateRentPenalty(
//         chargePenalty,
//         rent_penalty_setting,
//         rentAmount,
//         feePeriod as RentPeriod,
//         overduePeriods
//       );

//       console.log("overduePeriods", overduePeriods);
//       console.log("owingAmount", owingAmount);
//       console.log("penaltyAmount", calculatedPenalty);

//       setOverduePeriods(overduePeriods);
//       setOwingAmount(owingAmount);
//       setPenaltyAmount(calculatedPenalty);
//     } else {
//       console.log("Missing data for owing calculation:", {
//         start_date,
//         due_date,
//         feePeriod,
//         renewalTenantTotalPrice,
//       });
//     }
//   }, [
//     start_date,
//     due_date,
//     feePeriod,
//     renewalTenantTotalPrice,
//     chargePenalty,
//     rent_penalty_setting,
//     rentAmount,
//     setPenaltyAmount,
//     setOverduePeriods,
//   ]);

//   const feeDetails = useMemo(
//     () =>
//       getOwingFeeDetails({
//         isRental,
//         currency: currency as keyof typeof currencySymbols,
//         owingAmount,
//         overduePeriods,
//         unitData,
//         penaltyAmount,
//       }),
//     [isRental, currency, owingAmount, overduePeriods, unitData, penaltyAmount]
//   );

//   console.log("penaltyAmount", penaltyAmount);
//   console.log("feeDetails", feeDetails);

//   // Render if show is true and either owingAmount or penaltyAmount is non-zero
//   if (!show || (owingAmount <= 0 && penaltyAmount <= 0)) {
//     console.log("OwingFee not rendered:", { show, owingAmount, penaltyAmount });
//     return null;
//   }

//   // const feeDetails = useMemo(
//   //   () =>
//   //     getOwingFeeDetails({
//   //       isRental,
//   //       currency: currency as keyof typeof currencySymbols,
//   //       owingAmount,
//   //       overduePeriods,
//   //       unitData,
//   //       penaltyAmount,
//   //     }),
//   //   [isRental, currency, owingAmount, overduePeriods, unitData]
//   // );

//   console.log("penaltyAmount", penaltyAmount);
//   console.log("feeDetails", feeDetails);
//   // if (owingAmount <= 0 || !isUpfrontPaymentChecked) {
//   //   return null;
//   // }

//   if (!show || owingAmount <= 0) {
//     return null;
//   }

//   return (
//     <div className="space-y-6">
//       <RentSectionTitle>Outstanding Details</RentSectionTitle>
//       <FeeDetails
//         owing
//         noEdit
//         currency={currency}
//         title={isRental ? "Breakdown" : "Breakdown"}
//         feeDetails={feeDetails}
//         total_package={
//           Number(unitData.renewalTenantTotalPrice) + owingAmount + penaltyAmount
//         }
//         id={unitData.propertyId as string}
//       />
//     </div>
//   );
// };

// export default OwingFee;






















// "use client";
// import React, { useEffect, useState } from "react";
// // Imports
// import DocumentCheckbox from "@/components/Documents/DocumentCheckbox/document-checkbox";
// import useFetch from "@/hooks/useFetch";
// import { transformDocumenArticleResponse } from "./data";
// import { CheckboxOption, DocumentsAPIResponse } from "./types";
// import DOMPurify from "dompurify";
// import NetworkError from "../Error/NetworkError";
// import CheckBoxLoader from "../Loader/CheckBoxLoader";
// import { useRouter } from "next/navigation";
// import { toast } from "sonner";

// interface DocumentTenancyAgreementsProps {
//   id: number;
//   defaultOptions?: CheckboxOption[];
//   onOptionsChange?: (options: CheckboxOption[]) => void;
// }

// const DocumentTenancyAgreements: React.FC<DocumentTenancyAgreementsProps> = ({
//   id,
//   onOptionsChange,
//   defaultOptions = [],
// }) => {
//   const router = useRouter();

//   const { data, loading, error, isNetworkError } =
//     useFetch<DocumentsAPIResponse>(`/property-document/documents/${id}`);

//   const [checkboxOptions, setCheckboxOptions] = useState<CheckboxOption[]>([]);
//   const [selectedOptions, setSelectedOptions] = useState<CheckboxOption[]>([]);

//   // Set up options from API data
//   // useEffect(() => {
//   //   if (data) {
//   //     const options = transformDocumenArticleResponse(data);
//   //     setCheckboxOptions(options);

//   //     // Initialize selected options based on defaultOptions if available
//   //     if (defaultOptions && defaultOptions.length > 0) {
//   //       // Find matching options from API data and default options
//   //       const initialSelected = options.filter((option) =>
//   //         defaultOptions.some((defaultOpt) => defaultOpt.value === option.value)
//   //       );
//   //       setSelectedOptions(initialSelected);

//   //       if (onOptionsChange) {
//   //         onOptionsChange(initialSelected);
//   //       }
//   //     }
//   //   }
//   // }, [data, defaultOptions]);

//   useEffect(() => {
//     if (data) {
//       const options = transformDocumenArticleResponse(data);
//       // Only update checkboxOptions if different
//       setCheckboxOptions((prev) => {
//         const isSame =
//           prev.length === options.length &&
//           prev.every((opt, i) => opt.value === options[i]?.value);
//         return isSame ? prev : options;
//       });

//       // Initialize selected options based on defaultOptions
//       if (defaultOptions.length > 0) {
//         const initialSelected = options.filter((option) =>
//           defaultOptions.some((defaultOpt) => defaultOpt.value === option.value)
//         );
//         setSelectedOptions((prev) => {
//           const isSame =
//             prev.length === initialSelected.length &&
//             prev.every((opt, i) => opt.value === initialSelected[i]?.value);
//           if (!isSame) {
//             if (onOptionsChange) onOptionsChange(initialSelected);
//             return initialSelected;
//           }
//           return prev;
//         });
//       }
//     }
//   }, [data, defaultOptions, onOptionsChange]);

//   // Toggle the selected option when a DocumentCheckbox is clicked
//   const handleOptionToggle = (option: CheckboxOption) => {
//     setSelectedOptions((prev) => {
//       const exists = prev.find((item) => item.value === option.value);
//       if (exists) {
//         const filtered = prev.filter((item) => item.value !== option.value);
//         if (onOptionsChange) onOptionsChange(filtered);
//         return filtered;
//       } else {
//         const newSelected = [...prev, option];
//         if (onOptionsChange) onOptionsChange(newSelected);
//         return newSelected;
//       }
//     });
//   };

//   // Check if an option is selected
//   const isOptionSelected = (option: CheckboxOption) => {
//     return selectedOptions.some((item) => item.value === option.value);
//   };

//   if (isNetworkError) return <NetworkError />;
//   if (error) return <div>{error}</div>;
//   if (loading) return <CheckBoxLoader />;

//   return (
//     <div className="grid grid-cols-1 lg:grid-cols-2 gap-10">
//       {checkboxOptions.map((option) => (
//         <DocumentCheckbox
//           onClick={() => handleOptionToggle(option)}
//           key={option.value}
//           title={option.title}
//           checked={isOptionSelected(option)}
//         >
//           <div
//             dangerouslySetInnerHTML={{
//               __html: DOMPurify.sanitize(option.description),
//             }}
//           />
//         </DocumentCheckbox>
//       ))}
//     </div>
//   );
// };

// export default DocumentTenancyAgreements;














// import Link from "next/link";

// // Images
// import VerifiedIcon from "@/public/icons/verified.svg";

// // Types
// import type { MessageCardProps } from "./types";

// // Imports
// import clsx from "clsx";
// import { empty } from "@/app/config";
// import Picture from "../Picture/picture";
// import { SectionSeparator } from "../Section/section-components";
// import { getIconByContentType } from "@/app/(nav)/(messages-reviews)/messages/data";
// import { useGlobalStore } from "@/store/general-store";
// import { useRouter } from "next/navigation";

// const MessageCard: React.FC<MessageCardProps> = ({
//   id,
//   pfp = empty,
//   desc,
//   time,
//   fullname,
//   verified,
//   highlight,
//   messages = 0,
//   onClick,
//   content_type,
// }) => {
//   const router = useRouter();
//   const setGlobalStore = useGlobalStore((s) => s.setGlobalInfoStore);
//   const IconComponent = getIconByContentType(content_type as string);

//   const handleClick = () => {
//     // Set messageUserData in the store
//     setGlobalStore("messageUserData", {
//       id: Number(id),
//       branch_id: 1,
//       position: "",
//       name: fullname,
//       imageUrl: pfp,
//     });

//     // Call the provided onClick if it exists
//     if (onClick) {
//       onClick();
//     }

//     // Navigate to the message route
//     router.push(`/messages/${id}`);
//   };

//   const Children = () => (
//     <>
//       <div></div>
//       <div className="flex items-center gap-4">
//         <div className="flex items-center gap-2 flex-1">
//           <Picture
//             src={pfp || empty}
//             alt="profile picture"
//             size={60}
//             rounded
//             status={false}
//             containerClassName="custom-secondary-bg rounded-full"
//           />
//           <div className="custom-flex-col gap-1 flex-1">
//             <div className="flex items-center gap-[10px]">
//               <p className="text-text-primary dark:text-white text-base font-medium capitalize">
//                 {fullname}
//               </p>
//               {verified && (
//                 // <Picture src={VerifiedIcon} alt="verified" size={16} />
//               )}
//             </div>
//             {content_type === "text" ? (
//               <p className="text-text-quaternary dark:text-darkText-2 text-sm font-normal truncate w-full max-w-full">
//                 {desc}
//               </p>
//             ) : (
//               <div className="flex gap-1 text-sm items-center text-brand-9">
//                 {IconComponent && <IconComponent />}
//                 {content_type}
//               </div>
//             )}
//           </div>
//         </div>
//         <div className="flex flex-col gap-2 justify-center items-center font-normal">
//           <p className="text-text-disabled text-xs whitespace-nowrap">{time}</p>
//           {!!messages && (
//             <div className="w-4 h-4 pt-[1px] rounded-full flex items-center justify-center bg-highlight">
//               <p className="text-white dark:text-black text-[10px] leading-[10px]">
//                 {messages}
//               </p>
//             </div>
//           )}
//         </div>
//       </div>
//       <SectionSeparator />
//     </>
//   );

//   return (
//     <div
//       role="button"
//       tabIndex={0}
//       onClick={handleClick}
//       onKeyDown={(e) => {
//         if (e.key === "Enter" || e.key === " ") {
//           e.preventDefault();
//           handleClick();
//         }
//       }}
//       className={clsx(
//         "custom-flex-col gap-4 cursor-pointer transition-colors duration-200",
//         {
//           "bg-neutral-2 dark:bg-[#3C3D37]": highlight,
//           "hover:bg-neutral-1 dark:hover:bg-[#2A2B27]": !highlight, // Hover effect
//         }
//       )}
//     >
//       <Children />
//     </div>
//   );
//   // return onClick ? (
//   //   <button
//   //     type="button"
//   //     onClick={onClick}
//   //     className={clsx("custom-flex-col gap-4", {
//   //       "bg-neutral-2 dark:bg-[#3C3D37]": highlight,
//   //     })}
//   //   >
//   //     <Children />
//   //   </button>
//   // ) : (
//   //   <Link
//   //     href={`/messages/${id}`}
//   //     className={clsx("custom-flex-col gap-4", {
//   //       "bg-neutral-2 dark:bg-[#3C3D37]": highlight,
//   //     })}
//   //   >
//   //     <Children />
//   //   </Link>
//   // );
// };

// export default MessageCard;





// const Chat = () => {
//   const router = useRouter();
//   const { data, setChatData } = useChatStore();
//   const usersData = useChatStore((state) => state?.data?.users);
//   const { id } = useParams<{ id: string }>();
//   const user_id = useAuthStore((state) => state.user_id);
//   const users = usersData?.users || [];
//   const messageUserData = useGlobalStore((s) => s.messageUserData);
//   const setGlobalInfoStore = useGlobalStore((s) => s.setGlobalInfoStore);
//   const userId = Number(id);
//   const [isLoading, setIsLoading] = useState(true);
//   const store_messages = useChatStore((state) => state?.data?.conversations);
//   const [conversations, setConversations] = useState<any[]>([]);
//   const users_Id = getLocalStorage("user_id");
//   const [isPusherFailed, setIsPusherFailed] = useState(false);

//   // Memoize the callback to prevent re-subscribing on every render.
//   const handleNewMessage = useCallback(
//     (newMessage: Message) => {
//       console.log("Adding new message:", newMessage);
//       const updatedConversations = [...(store_messages || []), newMessage].sort(
//         (a, b) => a.id - b.id
//       );
//       setChatData("conversations", updatedConversations);
//     },
//     [store_messages, setChatData]
//   );

//   // Fetch messages from API
//   const fetchMessages = useCallback(async () => {
//     try {
//       const response = await api.get(`/messages/conversations/user/${id}`);
//       console.log("API response:", response.data);
//       if (response.data.status === "success") {
//         const mappedMessages: Message[] = response.data.messages.map(
//           (msg: any) => ({
//             id: msg.id,
//             text: msg.content ?? null,
//             senderId: msg.sender_id,
//             timestamp: `${msg.date} ${msg.timestamp}`,
//             content_type: msg.content_type,
//           })
//         );
//         console.log("Mapped messages:", mappedMessages);
//         setChatData("conversations", mappedMessages);
//       }
//     } catch (error: any) {
//       console.error("API error:", error.response?.data || error.message);
//     }
//   }, [id, setChatData]);

//   // Clear conversations and fetch messages when id changes
//   useEffect(() => {
//     setIsLoading(true);
//     setConversations([]);
//     setChatData("conversations", []);
//     if (id) {
//       fetchMessages();
//     } else {
//       setIsLoading(false);
//     }
//   }, [id, setChatData, fetchMessages]);

//   // Initiate Pusher listener with error handling
//   useConversationListener(id, handleNewMessage, (error: any) => {
//     console.error("Pusher connection failed:", error);
//     setIsPusherFailed(true); // Set failure state to trigger polling
//   });

//   // Polling logic when Pusher fails
//   useEffect(() => {
//     let pollingInterval: NodeJS.Timeout | null = null;

//     if (isPusherFailed) {
//       console.log("Switching to polling every 30 seconds...");
//       pollingInterval = setInterval(() => {
//         fetchMessages();
//       }, 30000);
//     }

//     // Cleanup polling on unmount or when Pusher reconnects (optional)
//     return () => {
//       if (pollingInterval) {
//         console.log("Stopping polling...");
//         clearInterval(pollingInterval);
//       }
//     };
//   }, [isPusherFailed, fetchMessages]);

//   // Initial fetch and cleanup
//   useEffect(() => {
//     setConversations([]);
//     setChatData("conversations", []);
//     if (id) fetchMessages();
//   }, [id, setChatData, fetchMessages]);

//   // useEffect(() => {
//   //   // Clear existing conversations
//   //   setConversations([]);
//   //   setChatData("conversations", []);
//   //   const fetchMessages = async () => {
//   //     try {
//   //       const response = await api.get(`/messages/conversations/user/${id}`);
//   //       console.log("API response:", response.data);
//   //       if (response.data.status === "success") {
//   //         const mappedMessages: Message[] = response.data.messages.map(
//   //           (msg: any) => ({
//   //             id: msg.id,
//   //             text: msg.content ?? null,
//   //             senderId: msg.sender_id,
//   //             timestamp: `${msg.date} ${msg.timestamp}`,
//   //             content_type: msg.content_type,
//   //           })
//   //         );
//   //         console.log("Mapped messages:", mappedMessages);
//   //         setChatData("conversations", mappedMessages);
//   //       }
//   //     } catch (error: any) {
//   //       console.error("API error:", error.response?.data || error.message);
//   //     }
//   //   };
//   //   if (id) fetchMessages();
//   // }, [id, setChatData]);

//   useEffect(() => {
//     console.log("Store messages updated:", store_messages);
//     if (store_messages && store_messages.length > 0) {
//       const groupedMessages = groupMessagesByDay(store_messages);
//       console.log("Grouped messages:", groupedMessages);
//       setConversations(groupedMessages);
//     }
//   }, [store_messages]);

//   useEffect(() => {
//     if (usersData) {
//       setIsLoading(false);
//     }
//   }, [usersData]);

//   if (isLoading) {
//     return <ChatSkeleton />;
//   }


//   // // If user not found, redirect to messages page.
//   const findUser = users.find((user: UsersProps) => Number(user.id) === userId);

//   const user = messageUserData || findUser;

//   console.log("user data", user);
//   if (!user) {
//     router.replace("/messages");
//     return null;
//   }

//   return (
//     <>
//       <div className="py-4 px-6 bg-neutral-2 dark:bg-black">
//         <div className="flex items-center gap-3">
//           <button onClick={() => router.push("/messages")}>
//             <Picture src="/icons/chevron-left.svg" alt="back" size={20} />
//           </button>
//           <Link
//             href={`/management/staff-branch/${user.branch_id}/branch-staff/${user?.staff_id}`}
//             className="flex items-center gap-4 text-left"
//           >
//             <Picture
//               src={user?.imageUrl || empty}
//               alt="profile picture"
//               containerClassName="custom-secondary-bg rounded-full"
//               size={32}
//               rounded
//               status={false}
//             />
//             <div className="custom-flex-col">
//               <p className="text-text-primary dark:text-white text-base font-medium capitalize">
//                 {user?.name}
//               </p>
//               <p className="text-text-disabled dark:text-darkText-2 text-[10px] font-normal">
//                 Tap here for contact info
//               </p>
//             </div>
//           </Link>
//         </div>
//       </div>
//       <div className="py-5 px-6 flex-1 overflow-auto custom-round-scrollbar bg-white dark:bg-black custom-flex-col gap-8">
//         {conversations.length > 0 &&
//           conversations.map((group, index) => (
//             <Messages
//               key={index}
//               day={group.day}
//               messages={group.messages}
//               userId={user_id as string}
//             />
//           ))}
//       </div>
//     </>
//   );
// };

// export default Chat;












// "use client";
// import { useEffect, useState } from "react";
// import LandlordTenantModalPreset from "../Management/landlord-tenant-modal-preset";
// import SettingsLegalDrawer, {
//   Checkbox,
// } from "../Settings/Modals/settings-legal-drawer";
// import { Drawer } from "@mui/material";
// import { useDrawerStore } from "@/store/drawerStore";
// import { checkboxOptions, transformDocumentsResponse } from "./data";
// import useFetch from "@/hooks/useFetch";
// import CheckBoxLoader from "../Loader/CheckBoxLoader";
// import OtherAgreement from "./other-agrement";
// import TenancyAgreement from "./TenancyAgrrement";

// const CreateTenancyAggrementModal = () => {
//   const [selectedOption, setSelectedOption] = useState<string | null>(null);
//   const { setSelectedLegalOption, selectedLegalOption } = useDrawerStore();
//   const [step, setStep] = useState<number>(0);

//   const [checkboxOptions, setCheckboxOptions] = useState<CheckboxOption[]>([]);
//   const { data, loading, error } = useFetch<DocumentsAPIResponse>(
//     "/property-document/documents"
//   );

//   const IS_TENANCY_SELECTED =
//     selectedLegalOption?.title === "Tenancy Agreement";

//   useEffect(() => {
//     if (data) {
//       const options = transformDocumentsResponse(data);
//       setCheckboxOptions(options);
//     }
//   }, [data]);

//   // HANDLE CHECKBOX CHANGE
//   const handleCheckboxChange = (value: string | number) => {
//     setSelectedOption(value.toString());
//     const selectedOption = checkboxOptions.find(
//       (option) => option.id === value
//     );
//     if (selectedOption) {
//       setSelectedLegalOption({
//         title: selectedOption.title,
//         description: selectedOption.description,
//         amount: selectedOption.amount ?? 0,
//         id: selectedOption.id ?? 0,
//       });
//     }
//   };

//   return (
//     <>
//       <LandlordTenantModalPreset
//         {...(selectedOption
//           ? { back: { handleBack: () => setSelectedOption(null) } }
//           : {})}
//         style={{ maxWidth: "714px", overflow: "visible" }}
//         heading={
//           selectedOption
//             ? checkboxOptions.find((option) => option.value === selectedOption)
//                 ?.title || ""
//             : "Tenancy Legal Procedure"
//         }
//       >
//         {selectedOption ? (
//           <>{IS_TENANCY_SELECTED ? <TenancyAgreement /> : <OtherAgreement />}</>
//         ) : (
//           <div className="flex flex-col gap-1">
//             <h2 className="text-text-primary text-[20px] font-bold dark:text-white text-base not-italic leading-[32px]">
//               Engage legal counsel.
//             </h2>
//             <p className="text-text-disabled dark:text-darkText-1 text-sm font-medium">
//               The legal steps and processes involved in renting or leasing
//               property, usually regulated by landlord-tenant laws and
//               regulations. Please choose any options below that are most
//               applicable to the property unit.
//             </p>
//           </div>
//         )}

//         {/* Render checkboxes only if no option is selected */}
//         {loading ? (
//           <CheckBoxLoader />
//         ) : (
//           !selectedOption && (
//             <div className="flex flex-col gap-4 mt-4">
//               {checkboxOptions.map((option) => (
//                 <Checkbox
//                   key={option.value}
//                   title={option.title}
//                   checked={selectedOption === option.value}
//                   groupName="legal_process"
//                   state={{
//                     isChecked: selectedOption === option.value,
//                     setIsChecked: () => {
//                       handleCheckboxChange(option.id ?? 0);
//                     },
//                   }}
//                   noCheckbox={true}
//                 >
//                   <p className="text-sm text-darkText-secondary capitalize text-text-disabled tracking-[0px]">
//                     {option.description}
//                   </p>
//                 </Checkbox>
//               ))}
//             </div>
//           )
//         )}
//       </LandlordTenantModalPreset>
//     </>
//   );
// };

// export default CreateTenancyAggrementModal;

// // DRAWER COMPONENT FLOW
// export const DrawerComponent = () => {
//   const { isDrawerOpen, closeDrawer, selectedLegalOption } = useDrawerStore();
//   return (
//     <Drawer
//       anchor="bottom"
//       open={isDrawerOpen}
//       onClose={closeDrawer}
//       classes={{ paper: "custom-round-scrollbar" }}
//       sx={{
//         "& .MuiPaper-root": {
//           borderTopLeftRadius: "32px",
//           borderTopRightRadius: "32px",
//           overflow: "auto",
//           height: "500px",
//         },
//         zIndex: 1,
//       }}
//     >
//       <SettingsLegalDrawer
//         onClose={closeDrawer}
//         noCheckbox={true}
//         selectedLegalOption={selectedLegalOption}
//       />
//     </Drawer>
//   );
// };






"use client";

import { useState, useEffect, useRef, useCallback } from "react";
import clsx from "clsx";
import BackButton from "@/components/BackButton/back-button";
import FilterBar from "@/components/FIlterBar/FilterBar";
import CustomTable from "@/components/Table/table";
import {
  walletTableFields,
  computeStatsTotals,
  determinePercentageDifference,
  determineTrend,
} from "../data";
import {
  initialPageData,
  transactionHistoryFilterMenu,
  transformAllTransactionsResponse,
} from "./data";
import TableLoading from "@/components/Loader/TableLoading";
import useFetch from "@/hooks/useFetch";
import type { AllTransactionsResponse, TransactionQueryParams } from "./types";
import type { FilterResult } from "@/components/Management/Landlord/types";
import { AxiosRequestConfig } from "axios";
import dayjs from "dayjs";
import NetworkError from "@/components/Error/NetworkError";
import { getTransactionIcon } from "@/components/Wallet/icons";
import { useGlobalStore } from "@/store/general-store";
import ServerError from "@/components/Error/ServerError";
import WalletAnalytics from "@/components/Wallet/wallet-analytics";
import { DateRangeSelector } from "./components";
import { useSearchParams } from "next/navigation";

const TransactionHistory = () => {
  const [state, setState] = useState(initialPageData);
  const setGlobalStore = useGlobalStore((s) => s.setGlobalInfoStore);
  const branchWalletTransactions = useGlobalStore(
    (s) => s.branchWalletTransactions
  );
  const timeRange = useGlobalStore((s) => s.timeRange);
  const selectedDateRange = useGlobalStore((s) => s.selectedDateRange);
  const filteredTransactions = useGlobalStore((s) => s.wallet_transactions);
  const [config, setConfig] = useState<AxiosRequestConfig>({
    params: {
      page: 1,
    } as TransactionQueryParams,
  });
  const observer = useRef<IntersectionObserver | null>(null);
  const isBranch = Number(useSearchParams().get("branch")) > 0;

  const [appliedFilters, setAppliedFilters] = useState<FilterResult>({
    options: [],
    menuOptions: {},
    startDate: null,
    endDate: null,
  });

  const isFilterApplied = () => {
    const { options, menuOptions, startDate, endDate } = appliedFilters;
    return (
      options.length > 0 ||
      Object.keys(menuOptions).some((key) => menuOptions[key].length > 0) ||
      startDate !== null ||
      endDate !== null
    );
  };

  const {
    data: apiData,
    loading,
    silentLoading,
    error,
    isNetworkError,
  } = useFetch<AllTransactionsResponse>("transactions", config);

  const TRANSACTIONS = isBranch ? branchWalletTransactions : state.transactions;

  // Compute stats for filtered transactions
  const currentTotals = computeStatsTotals(
    TRANSACTIONS || [],
    selectedDateRange
  );
  // const currentTotals = computeStatsTotals(
  //   state.transactions,
  //   selectedDateRange
  // );

  // Compute totals for the previous period
  const previousRange = (() => {
    if (!selectedDateRange?.from || !selectedDateRange?.to) {
      return undefined;
    }
    const fromDate = new Date(selectedDateRange.from);
    const toDate = new Date(selectedDateRange.to);
    const rangeDays =
      Math.ceil(
        (toDate.getTime() - fromDate.getTime()) / (1000 * 60 * 60 * 24)
      ) + 1;
    const previousFrom = new Date(fromDate);
    previousFrom.setDate(fromDate.getDate() - rangeDays);
    const previousTo = new Date(fromDate);
    previousTo.setDate(fromDate.getDate() - 1);
    return { from: previousFrom, to: previousTo };
  })();
  // const previousTotals = computeStatsTotals(state.transactions, previousRange);
  const previousTotals = computeStatsTotals(TRANSACTIONS || [], previousRange);

  // Percentage differences and trends
  const fundsPercent = determinePercentageDifference(
    previousTotals.total_funds,
    currentTotals.total_funds
  );
  const fundsUpDown = determineTrend(
    currentTotals.total_funds,
    previousTotals.total_funds
  );

  const debitPercent = determinePercentageDifference(
    previousTotals.total_debit,
    currentTotals.total_debit
  );
  const debitUpDown = determineTrend(
    currentTotals.total_debit,
    previousTotals.total_debit
  );

  const creditPercent = determinePercentageDifference(
    previousTotals.total_credit,
    currentTotals.total_credit
  );
  const creditUpDown = determineTrend(
    currentTotals.total_credit,
    previousTotals.total_credit
  );

  // Save stats and date range to global store
  useEffect(() => {
    setGlobalStore("wallet_stats", {
      total_funds: currentTotals.total_funds,
      total_debit: currentTotals.total_debit,
      total_credit: currentTotals.total_credit,
      funds_trend: {
        from: `previous ${
          timeRange === "90d"
            ? "3 months"
            : timeRange === "30d"
            ? "30 days"
            : timeRange === "7d"
            ? "7 days"
            : timeRange === "1d"
            ? "day"
            : "period"
        }`,
        type: fundsUpDown as "up" | "down" | "none",
        percent: Number(fundsPercent),
      },
      debit_trend: {
        from: `previous ${
          timeRange === "90d"
            ? "3 months"
            : timeRange === "30d"
            ? "30 days"
            : timeRange === "7d"
            ? "7 days"
            : timeRange === "1d"
            ? "day"
            : "period"
        }`,
        type: debitUpDown as "up" | "down" | "none",
        percent: Number(debitPercent),
      },
      credit_trend: {
        from: `previous ${
          timeRange === "90d"
            ? "3 months"
            : timeRange === "30d"
            ? "30 days"
            : timeRange === "7d"
            ? "7 days"
            : timeRange === "1d"
            ? "day"
            : "period"
        }`,
        type: creditUpDown as "up" | "down" | "none",
        percent: Number(creditPercent),
      },
    });
    setGlobalStore("wallet_date_range", { timeRange, selectedDateRange });
  }, [
    currentTotals,
    fundsPercent,
    fundsUpDown,
    debitPercent,
    debitUpDown,
    creditPercent,
    creditUpDown,
    timeRange,
    selectedDateRange,
    setGlobalStore,
  ]);

  const fetchNextPage = useCallback(() => {
    if (state.hasMore && !silentLoading) {
      setConfig((prev) => ({
        params: {
          ...prev.params,
          page: state.current_page + 1,
        } as TransactionQueryParams,
      }));
    }
  }, [state.hasMore, silentLoading, state.current_page]);

  const lastRowRef = useCallback(
    (node: HTMLElement | null) => {
      if (observer.current) observer.current.disconnect();
      observer.current = new IntersectionObserver((entries) => {
        if (entries[0].isIntersecting && state.hasMore) {
          fetchNextPage();
        }
      });
      if (node) observer.current.observe(node);
    },
    [fetchNextPage, state.hasMore]
  );

  useEffect(() => {
    if (apiData) {
      setState((prevState) => {
        const newTransactions = transformAllTransactionsResponse(apiData);
        const combinedTransactions = [
          ...prevState.transactions,
          ...newTransactions.transactions,
        ];
        const uniqueTransactions = combinedTransactions.filter(
          (transaction, index, self) =>
            index === self.findIndex((t) => t.id === transaction.id)
        );

        // Save unique transactions to global store
        setGlobalStore("wallet_transactions", uniqueTransactions);

        if (newTransactions.current_page === 1) {
          return {
            ...prevState,
            ...newTransactions,
            transactions: uniqueTransactions,
          };
        } else {
          return {
            ...prevState,
            transactions: uniqueTransactions,
            current_page: newTransactions.current_page,
            total_pages: newTransactions.total_pages,
            hasMore: newTransactions.hasMore,
          };
        }
      });
    }
  }, [apiData, setGlobalStore]);

  // const transformedWalletTableData = state.transactions.map((t, index) => ({
  const transformedWalletTableData = (TRANSACTIONS || []).map((t, index) => ({
    ...t,
    amount: (
      <span
        className={clsx({
          "text-status-success-3": t.type === "credit",
          "text-status-error-primary": t.type === "debit",
        })}
      >
        {`${t.type === "credit" ? "+" : t.type === "debit" ? "-" : ""}${
          t.amount
        }`}
      </span>
    ),
    icon: (
      <div
        className={clsx(
          "flex items-center justify-center w-9 h-9 rounded-full",
          {
            "bg-status-error-1 text-status-error-primary": t.type === "debit",
            "bg-status-success-1 text-status-success-primary":
              t.type === "credit" || t.type === "DVA",
          }
        )}
      >
        {getTransactionIcon(t.source, t.transaction_type)}
      </div>
    ),
    ref: index === state.transactions.length - 1 ? lastRowRef : null,
  }));

  const handleFilterApply = (filters: FilterResult) => {
    setAppliedFilters(filters);
    const { menuOptions, startDate, endDate } = filters;
    const queryParams: TransactionQueryParams = {
      page: 1,
    };
    const status = menuOptions["Status"]?.[0];
    const type = menuOptions["Type"]?.[0];
    if (startDate) {
      queryParams.from = dayjs(startDate).format("YYYY-MM-DD");
    }
    if (endDate) {
      queryParams.to = dayjs(endDate).format("YYYY-MM-DD");
    }
    if (status) {
      queryParams.status = status;
    }
    if (type) {
      queryParams.type = type;
    }
    setConfig({
      params: queryParams,
    });
  };

  // Get display text for current timeRange
  const getTimeRangeDisplayText = () => {
    switch (timeRange) {
      case "90d":
        return "Last 3 months";
      case "30d":
        return "Last 30 days";
      case "7d":
        return "Last 7 days";
      case "1d":
        return "Yesterday";
      case "custom":
        return "Custom";
      default:
        return "Last 30 days";
    }
  };

  if (isNetworkError) return <NetworkError />;
  if (error) return <ServerError error={error} />;

  return (
    <div className="custom-flex-col gap-8">
      <div className="flex justify-between items-center">
        <FilterBar
          pageTitle="Transaction History"
          hasGridListToggle={false}
          handleFilterApply={handleFilterApply}
          hiddenSearchInput
          exports
          isDateTrue
          exportHref="/wallet/audit-trail/export"
          filterOptionsMenu={transactionHistoryFilterMenu}
          appliedFilters={appliedFilters}
          fileLabel={"Wallet Transactions"}
          xlsxData={filteredTransactions}
          onBack
        />
        {/* <DateRangeSelector /> */}
      </div>
      <div className="flex flex-col xl:flex-row gap-8">
        <div className="custom-flex-col gap-10 flex-1">
          <div className="flex flex-col lg:flex-row gap-6">
            <WalletAnalytics
              title="funds"
              amount={currentTotals.total_funds}
              trend={{
                from: `previous ${
                  timeRange === "90d"
                    ? "3 months"
                    : timeRange === "30d"
                    ? "30 days"
                    : timeRange === "7d"
                    ? "7 days"
                    : timeRange === "1d"
                    ? "day"
                    : "period"
                }`,
                type: fundsUpDown as "up" | "down" | "none",
                percent: Number(fundsPercent),
              }}
            />
            <WalletAnalytics
              title="debit"
              amount={currentTotals.total_debit}
              trend={{
                from: `previous ${
                  timeRange === "90d"
                    ? "3 months"
                    : timeRange === "30d"
                    ? "30 days"
                    : timeRange === "7d"
                    ? "7 days"
                    : timeRange === "1d"
                    ? "day"
                    : "period"
                }`,
                type: debitUpDown as "up" | "down" | "none",
                percent: Number(debitPercent),
              }}
            />
            <WalletAnalytics
              title="credit"
              amount={currentTotals.total_credit}
              trend={{
                from: `previous ${
                  timeRange === "90d"
                    ? "3 months"
                    : timeRange === "30d"
                    ? "30 days"
                    : timeRange === "7d"
                    ? "7 days"
                    : timeRange === "1d"
                    ? "day"
                    : "period"
                }`,
                type: creditUpDown as "up" | "down" | "none",
                percent: Number(creditPercent),
              }}
            />
          </div>
        </div>
      </div>
      {loading ? (
        <TableLoading />
      ) : (
        <section>
          <CustomTable
            fields={walletTableFields}
            data={transformedWalletTableData}
            tableBodyCellSx={{
              paddingTop: "12px",
              paddingBottom: "12px",
              fontSize: "16px",
              whiteSpace: "nowrap",
            }}
            tableHeadCellSx={{
              paddingTop: "14px",
              paddingBottom: "14px",
              fontSize: "16px",
            }}
          />
          {silentLoading && (
            <div className="flex items-center justify-center py-4">
              <div className="loader" />
            </div>
          )}
        </section>
      )}
    </div>
  );
};

export default TransactionHistory;
