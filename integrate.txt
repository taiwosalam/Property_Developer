 const handleClickSend = async () => {
    if (activeStep === "send funds") {
      if (!description) {
        toast.warning("Please enter a description");
        return;
      }
      if (!(amount > 0)) {
        toast.warning("Please enter an amount");
        return;
      }
      if (branch && amount > Number(balance.my_balance)) {
        toast.warning("Insufficient balance");
        return;
      }
      setActiveStep("confirm pin");
    } else {
      if (pin.length !== 4) {
        toast.warning("Please enter your PIN");
        return;
      }
      setLoading(true);
      const action = branch
        ? branchFundWallet({ wallet_id, amount, pin, description })
        : transferFunds(wallet_id, amount, description, pin);
      const status = await action;
      if (status) {
        setIsOpen(false);
        if (!isAlreadyBeneficiary && saveAsBeneficiary && my_wallet_id) {
          await addBeneficiary(wallet_id, my_wallet_id, {
            noToast: true,
          });
        }
        window.dispatchEvent(new Event("refetch-wallet"));
      }
      setLoading(false);
    }
  };











 const handleUpdateProfile = async (data: Record<string, string>) => {
    const paylo
    ad = {
      name: data.fullname,
      title: data.personal_title,
      // estate_title: data.real_estate_title,
      // email: data.email,
      // phone_number: data.phone_number,
      // gender: data.gender,
    };
    // cleanPhoneNumber(payload);
    // if (!payload.phone_number) {
    //   payload.phone_number = "";
    // }

    try {
      setReqLoading(true);
      const status = await updateUserProfile(objectToFormData(payload));
      if (status) {
        setNext(true);
        window.dispatchEvent(new Event("fetch-profile"));
      }
    } catch (error) {
      toast.error("Error updating profile");
    } finally {
      setReqLoading(false);
      setNext(false);
    }
  };















    // const handleSubmit = async(data: Record<string, string>) => {
  //   if (isForgetPin) {
  //     setIsForgetPin(false); // Reset `isForgetPin`
  //     setIsOpen(true); 
  //     try{
  //       // const response = await 
  //       console.log("Goin to API", data)
  //     } catch (error) {
  //       console.error(error);
  //     }
  //   } else {
  //     setIsOpen(true); // Open the modal directly
  //     try{
  //       // const response = await 
  //       console.log("Goin to API", data)
  //     } catch (error) {
  //       console.error(error);
  //     }
  //   }
  // };




















  "use client";

import React, { useEffect, useRef, useState } from "react";

// Types
import type { DefaultSettingsModalProps } from "../types";

// Imports
import PinField from "react-pin-field";
import Button from "@/components/Form/Button/button";
import WalletModalPreset from "@/components/Wallet/wallet-modal-preset";
import Input from "@/components/Form/Input/input";
import { AuthForm } from "@/components/Auth/auth-components";
import { useWalletStore } from "@/store/wallet-store";
import { WalletDataResponse } from "@/app/(nav)/wallet/data";
import useFetch from "@/hooks/useFetch";
import { toast } from "sonner";
import { ForgetWalletPinPassword } from "@/app/(nav)/settings/profile/data";

const ForgetWalletModal: React.FC<DefaultSettingsModalProps> = ({
  changeStep,
}) => {
  const pinFieldRef = useRef<HTMLInputElement[] | null>(null);
  const [loading, setLoading] = useState(false)
  const setWalletStore = useWalletStore((s) => s.setWalletStore)
  const { data, error, refetch } =
  useFetch<WalletDataResponse>("/wallets/dashboard");
  
  const walletId = data?.balance.wallet_id;
  setWalletStore("walletId", walletId as string);

  useEffect(() => {
    if (pinFieldRef.current && pinFieldRef.current.length > 0) {
      pinFieldRef.current[0].focus();
    }
  }, []);

  const hanldeForgetPassword = async(data: Record<string, string>)=>{
    try{
      setLoading(true)
      const payload = {
        wallet_id: walletId as string,
        password: data.password
      }
      console.log("payload", payload)
      const res = await ForgetWalletPinPassword(payload);
      if(res){
        toast.success("Wallet pin changed successfully")
        changeStep(3);
      }
    } catch (err){
        toast.error("Failed to forget wallet password")
    } finally{
      setLoading(false)
    }
  }

  return (
    <WalletModalPreset
      title="Forget Wallet PIN"
      style={{ width: 390, borderRadius: 20 }}
    >
    <AuthForm onFormSubmit={hanldeForgetPassword} autoComplete="off">
      <div className="custom-flex-col gap-20">
        <div className="custom-flex-col gap-10">
          <p className="text-text-tertiary text-center text-sm font-medium">
          Please enter your password to proceed with resetting your wallet PIN securely. This ensures your account remains protected and only authorized changes are made.
          </p>
          <div className="flex gap-6 justify-center">
           <Input
            id="password"
            label="Enter Password"
            type="password"
            inputClassName="w-full"
            className="w-full"
           />
          </div>
        </div>
        <Button
          size="sm_medium"
          type="submit"
          className="py-2 px-8"
        >
          {loading ? "Please wait..." : "Proceed"}
        </Button>
      </div>
      </AuthForm>
    </WalletModalPreset>
  );
};

export default ForgetWalletModal;


















                {/* <Select
                  options={landlordOptions}
                  id="land_lord_id"
                  label="Landlord"
                  inputContainerClassName="bg-white"
                  resetKey={resetKey}
                  defaultValue={
                    editMode && propertyDetails?.land_lord_id
                      ? landlordOptions.find(
                          (landlord) => landlord.value === propertyDetails.land_lord_id
                        )
                      : undefined
                  }
                  hiddenInputClassName="property-form-input"
                  placeholder={
                    landlordsLoading
                      ? "Loading landlords..."
                      : landlordsError
                      ? "Error loading landlords"
                      : "Select landlord"
                  }
                  error={landlordsError}
                /> */}




=================FILTER MODAL ==================
import { useState } from "react";
import { ModalTrigger } from "@/components/Modal/modal";
import { ChevronRight, ChevronLeft } from "lucide-react";
import DateInput from "@/components/Form/DateInput/date-input";
import dayjs, { Dayjs } from "dayjs";
import Button from "@/components/Form/Button/button";
import { FilterModalProps, FilterOptionMenu } from "./types";
import { CancelIcon, CheckboxCheckedIcon } from "@/public/icons/icons";
import { useModal } from "@/components/Modal/modal";
import Checkbox from "@/components/Form/Checkbox/checkbox";

const FilterModal: React.FC<FilterModalProps> = ({
  filterOptions,
  filterOptionsMenu,
  handleFilterApply,
  filterTitle = "Filters by",
  isDateTrue,
  dateLabel = "Date",
  appliedFilters,
}) => {
  const { setIsOpen } = useModal();
  const isRadio =
    typeof filterOptions === "object" &&
    !Array.isArray(filterOptions) &&
    filterOptions.radio;

  const [selectedStartDate, setSelectedStartDate] = useState<string | null>(
    appliedFilters?.startDate || null
  );
  const [selectedEndDate, setSelectedEndDate] = useState<string | null>(
    appliedFilters?.endDate || null
  );

  const handleDateChange = (type: "start" | "end", date?: Dayjs | null) => {
    if (type === "start") {
      setSelectedStartDate(date && date.isValid() ? date.toISOString() : null);
    } else if (type === "end") {
      setSelectedEndDate(date && date.isValid() ? date.toISOString() : null);
    }
  };

  // Apply filters and close modal
  const handleApplyFilter = () => {
    const selectedOptions = [...selectedFilters];
    const selectedMenuOptions = { ...selectedFilterMenus };
    const filtersToApply = {
      options: selectedOptions,
      menuOptions: selectedMenuOptions,
      startDate: selectedStartDate,
      endDate: selectedEndDate,
    };
    handleFilterApply(filtersToApply);
    setIsOpen(false);
  };

  const [searchQuery, setSearchQuery] = useState("");
  const [selectedFilters, setSelectedFilters] = useState<string[]>(() => {
    if (appliedFilters?.options) return appliedFilters.options;
    
    // Find radio group with default checked option
    const defaultRadioValue = filterOptionsMenu?.find(menu => menu.radio)
      ?.value.find(option => option.isChecked)?.value;
    
    if (defaultRadioValue) {
      return [String(defaultRadioValue)];
    }
    
    return [];
  });
  const [selectedFilterMenus, setSelectedFilterMenus] = useState<Record<string, string[]>>(() => {
    if (appliedFilters?.menuOptions) return appliedFilters.menuOptions;
    
    // Initialize radio groups with default values
    const initialMenus: Record<string, string[]> = {};
    filterOptionsMenu?.forEach(menu => {
      if (menu.radio) {
        const defaultValue = menu.value.find(option => option.isChecked)?.value;
        if (defaultValue) {
          initialMenus[menu.label] = [String(defaultValue)];
        }
      }
    });
    
    return initialMenus;
  });
  const [view, setView] = useState<"default" | "date" | "menu">("default");
  const commonCheckboxClasses =
    "flex-row-reverse w-full justify-between bg-[#F5F5F5] dark:bg-[#3C3D37] py-2 px-4 capitalize";
  const commonLabelClasses =
    "text-text-secondary dark:text-darkText-1 font-medium flex items-center justify-between py-2 px-4 bg-[#F5F5F5] dark:bg-[#3C3D37] capitalize cursor-pointer";
  const [activeOptionMenu, setActiveOptionMenu] =
    useState<FilterOptionMenu | null>(null);

  const handleOptionMenuClick = (option: FilterOptionMenu) => {
    setSearchQuery("");
    setActiveOptionMenu(option);
    setView("menu");
  };

  const handleOptionClick = (value: string) => {
    setSelectedFilters((prev) =>
      prev.includes(value) ? prev.filter((x) => x !== value) : [...prev, value]
    );
  };

  const handleOptionMenuItemClick = (
    menuLabel: string,
    value: string,
    isRadio?: boolean
  ) => {
    setSelectedFilterMenus((prev) => {
      const currentSelections = prev[menuLabel] || [];
      if (isRadio) {
        return {
          ...prev,
          [menuLabel]: currentSelections.includes(value) ? [] : [value],
        };
      } else {
        const newSelections = currentSelections.includes(value)
          ? currentSelections.filter((v) => v !== value)
          : [...currentSelections, value];
        return { ...prev, [menuLabel]: newSelections };
      }
    });
  };

  const filteredOptions = activeOptionMenu?.value.filter((option) =>
    option.label.toLowerCase().includes(searchQuery.toLowerCase())
  );

  return (
    <div className="w-[400px] max-h-[90vh] overflow-y-auto rounded-[20px] bg-white dark:bg-darkText-primary p-[20px] custom-flex-col">
      <div className="flex items-center justify-between border-b border-solid border-gray-300 ">
        <div className="flex items-center gap-1">
          {view !== "default" && (
            <button
              onClick={() => {
                setView("default");
                setActiveOptionMenu(null);
              }}
            >
              <ChevronLeft />
            </button>
          )}
          <h2 className="text-lg font-bold text-primary-navy dark:text-white">
            {view === "default"
              ? filterTitle
              : view === "date"
                ? dateLabel
                : activeOptionMenu?.label}
          </h2>
        </div>
        {view === "default" && (
          <ModalTrigger close className="p-2">
            <CancelIcon />
          </ModalTrigger>
        )}
      </div>
      <div className="space-y-2 my-4">
        {view === "default" ? (
          <>
            {isDateTrue && (
              <div
                role="button"
                className={commonLabelClasses}
                onClick={() => setView("date")}
              >
                <span>{dateLabel}</span>
                {selectedStartDate || selectedEndDate ? (
                  <CheckboxCheckedIcon />
                ) : (
                  <ChevronRight className="text-[#344054]" />
                )}
              </div>
            )}
            {filterOptionsMenu?.map((option, i) => (
              <div
                key={i}
                role="button"
                className={commonLabelClasses}
                onClick={() => handleOptionMenuClick(option)}
              >
                <span>{option.label}</span>
                {selectedFilterMenus[option.label] &&
                  selectedFilterMenus[option.label].length > 0 ? (
                  <CheckboxCheckedIcon />
                ) : (
                  <ChevronRight className="text-[#344054]" />
                )}
                {option.isChecked && (
                  <Checkbox
                    checked={selectedFilters.includes(String(option.value)) || option.isChecked}
                    onChange={() => handleOptionClick(String(option.value))}
                  />
                )}
              </div>
            ))}
            {!isRadio &&
              Array.isArray(filterOptions) &&
              filterOptions.map((option, i) => (
                <Checkbox
                  key={i}
                  className={commonCheckboxClasses}
                  checked={selectedFilters.includes(option.value)}
                  onChange={() => handleOptionClick(option.value)}
                >
                  {option.label}
                </Checkbox>
              ))}
            {isRadio &&
              Array.isArray(filterOptions?.value) &&
              filterOptions.value.map((option, i) => (
                <Checkbox 
                  key={i}
                  radio={true}
                  className={commonCheckboxClasses}
                  checked={selectedFilters.includes(option.value)}
                  onChange={() => {
                    setSelectedFilters([option.value]);
                  }}
                >
                  {option.label}
                </Checkbox>
              ))}
           </>
        ) : view === "date" ? (
          <>
            <DateInput
              label="From"
              id="date_from"
              value={selectedStartDate ? dayjs(selectedStartDate) : undefined}
              onChange={(date) => handleDateChange("start", date)}
              disableFuture
            />
            <DateInput
              label="To"
              id="date_to"
              value={selectedEndDate ? dayjs(selectedEndDate) : undefined}
              onChange={(date) => handleDateChange("end", date)}
              disableFuture
            />
          </>
        ) : (
          <>
            <input
              type="text"
              className="w-full border p-2"
              placeholder="Search"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
            />
            <div className="max-h-[200px] overflow-y-auto pr-1 custom-round-scrollbar space-y-2 my-2">
              {filteredOptions?.map((option, i) => (
                <Checkbox
                  key={i}
                  radio={activeOptionMenu?.radio}
                  className={commonCheckboxClasses}
                  checked={selectedFilterMenus[
                    activeOptionMenu!.label
                  ]?.includes(option.value)}
                  onChange={() =>
                    handleOptionMenuItemClick(
                      activeOptionMenu!.label,
                      option.value,
                      activeOptionMenu!.radio
                    )
                  }
                >
                  {option.label}
                </Checkbox>
              ))}
            </div>
          </>
        )}
      </div>
      <Button
        className="w-full py-2 rounded-lg mt-4"
        size="base_medium"
        onClick={() => {
          if (view === "default") {
            handleApplyFilter();
          } else {
            setView("default");
          }
        }}
      >
        {view === "default" ? "Apply Filters" : "OK"}
      </Button>
    </div>
  );
};

export default FilterModal;















// Login function
export const login = async (formData: Record<string, any>) => {
  try {
    const { data } = await axios.post<LoginResponse>(
      `${base_url}login`,
      formData
    );
    useAuthStore.getState().reset();
    const token = data.access_token;
    const email = data.data.details?.email || formData.email;
    const emailVerified = data.data.details.email_verification;
    const role = data.data.details.role[0];
    // console.log('res', data);
    const additional_details = data.additional_details;
    const details = {
      branch: {
        branch_id: additional_details.branch?.id || null,
        picture: additional_details.branch?.picture || null,
      },
      company: {
        company_id: additional_details.id || null,
        company_logo: additional_details.company_logo || null,
      },
    };

    // SAVE TO ZUSTAND
    useAuthStore.getState().setAuthState('token', token);
    useAuthStore.getState().setAuthState('email', email);
    useAuthStore.getState().setAuthState('role', role);
    useAuthStore.getState().setAuthState('additional_details', details);

    // SECURE ROLE
    await saveRoleToCookie(role);
    await saveClientRoleToCookie(role);
    if (emailVerified) {
      toast.success(data?.message || 'Login successful!');
      if (role === 'user') {
        return 'redirect to setup';
      } else {
        useWalletStore
          .getState()
          .setWalletStore('walletPinStatus', data.wallet_pin_status);
        useWalletStore.getState().setWalletStore('walletId', data.wallet_id);
        return 'redirect to dashboard';
      }
    }
    if (!emailVerified) {
      useAuthStore.getState().setAuthState('emailVerified', false);
      toast.warning('Please verify your email to continue');
      return 'redirect to verify email';
    }
  } catch (error) {
    handleAxiosError(error, 'Login failed. Please try again.');
  }
};


















============SETTITNGS SIGNATURE

"use client";

import React, { useEffect, useState } from "react";

// Images
import { Check } from "lucide-react";
import DangerIcon from "@/public/icons/danger.svg";
import ImageBlue from "@/public/icons/image-blue.svg";
import SignatureImage from "@/public/accounting/signature.svg";

// Imports
import { industryOptions, titles } from "@/data";
import Input from "@/components/Form/Input/input";
import Picture from "@/components/Picture/picture";
import Select from "@/components/Form/Select/select";
import { useImageUploader } from "@/hooks/useImageUploader";
import SettingsSection from "@/components/Settings/settings-section";

import {
  SettingsSectionTitle,
  SettingsUpdateButton,
} from "@/components/Settings/settings-components";
import { usePersonalInfoStore } from "@/store/personal-info-store";
import { toast } from "sonner";
import { AuthForm } from "@/components/Auth/auth-components";
import { createSignatureProfiles, FormState } from "@/app/(nav)/settings/security/data";
import useFetch from "@/hooks/useFetch";
import useRefetchOnEvent from "@/hooks/useRefetchOnEvent";
import { transformSignature } from "@/app/(nav)/settings/data";

// /company-signatures
interface SignaturePageData {
  name: string;
  professional_title: string;
  signature_image: string;
  title: string;
}[]

const SettingsSignature = () => {
  const [state, setState] = useState<SignaturePageData[]>([]);
  const { preview, inputFileRef, handleImageChange } = useImageUploader();
  const {
    data: apiData,
    loading,
    silentLoading,
    isNetworkError,
    error,
    refetch,
  } = useFetch<any>("/company-signatures");
  useRefetchOnEvent("refetchSignatures", () => refetch({ silent: true }));

  // useEffect(() => {
  //   if (apiData) {
  //     setState(transformSignature(apiData));
  //   }
  // }, [apiData]);

  useEffect(() => {
    // Assuming apiData is defined somewhere in your component
    if (apiData) {
        const transformedData = transformSignature(apiData);
        setState(transformedData);

        // Update inputFields based on new state
        setInputFields(transformedData.length > 0 ? transformedData.map(signature => ({
            id: Date.now(), // Generate unique IDs
            signature: signature.signature_image,
            signatureFile: new File([], ""), // Create File only on the client
        })) : [{
            id: Date.now(),
            signature: 'Default Signature Image', // Replace with actual default if needed
            signatureFile: new File([], ""),
        }]);
    }
}, [apiData]);

  console.log("signature", state)

  // const [inputFields, setInputFields] = useState(() => {
  //   if (typeof window !== "undefined") {
  //     return [
  //       {
  //         id: Date.now(),
  //         signature: SignatureImage,
  //         signatureFile: new File([], ""), // Create File only on the client
  //       },
  //     ];
  //   }
  //   return [];
  // });

  const [inputFields, setInputFields] = useState(() => {
    if (typeof window !== "undefined") {
        // Check if state is empty and use default values if so
        if (state.length > 0) {
            return state.map(signature => ({
                id: Date.now(), // You might want to generate unique IDs differently
                signature: signature.signature_image,
                signatureFile: new File([], ""), // Create File only on the client
                name: signature.name,
                title: signature.title,
                professional_title: signature.professional_title
            }));
        } else {
            return [
                {
                    id: Date.now(),
                    signature: SignatureImage, // Replace with actual default if needed
                    signatureFile: new File([], ""), // Create File only on the client
                },
            ];
        }
    }
    return [];
});


  const [reqLoading, setReqLoading] = useState(false);
  const [next, setNext] = useState(false);
  const changeImage = () => {
    inputFileRef.current?.click();
  };

  const addInputField = () => {
    setInputFields([
      ...inputFields,
      { id: Date.now(), signature: SignatureImage, signatureFile: new File([], "") },
    ]);
  };

  const removeInputField = (id: number) => {
    const updatedFields = inputFields.filter((field) => field.id !== id);
    setInputFields(updatedFields);
    console.log("Input Fields after removing:", updatedFields);
  };

  const changeSignatureImage = (index: number) => {
    document.getElementById(`signature_input_${index}`)?.click();
  };

  const handleSignatureChange =
    (index: number) => (e: React.ChangeEvent<HTMLInputElement>) => {
      if (typeof window === "undefined" || !e.target.files || !e.target.files[0]) {
        return;
      }
      if (e.target.files && e.target.files[0]) {
        const newSignature = URL.createObjectURL(e.target.files[0]);
        const newFile = e.target.files[0];
        setInputFields(
          inputFields.map((inputField) =>
            inputField.id === inputFields[index].id
              ? { ...inputField, signature: newSignature, signatureFile: newFile }
              : inputField
          )
        );
      }
    };

  const hanleCreateSignature = async (data: FormData) => {
    const formData = new FormData();

    inputFields.forEach((field, index) => {
      formData.append(`name[${index}]`, data.get(`fullname_${index}`) as string);
      formData.append(`title[${index}]`, data.get(`personal_title_qualification_${index}`) as string);
      formData.append(`professional_title[${index}]`, data.get(`real_estate_title_${index}`) as string);
      formData.append(`signature[${index}]`, field.signatureFile); // Binary file
    });

    console.log("Payload:", Object.fromEntries(formData));

    try {
      setReqLoading(true);
      const res = await createSignatureProfiles(formData);
      if (res) {
        toast.success("Signature created successfully");
        setNext(true);
        window.dispatchEvent(new Event("fetch-profile"));
      }
    } catch (error) {
      toast.error("Error creating signature");
    } finally {
      setReqLoading(false);
    }
  };

  return (
    <SettingsSection title="Authorized Signature">
      <AuthForm onFormSubmit={hanleCreateSignature} returnType="form-data">
        <div className="custom-flex-col gap-8">
          <div className="custom-flex-col gap-6">
            <SettingsSectionTitle
              title=""
              desc="This signature is affixed to every document requiring authorization. Please sign on a plain white paper and take a photo for uploading. If possible, remove the background picture of the signature before uploading for a cleaner appearance."
            />
            <div className="custom-flex-col gap-[18px]">
              <div className="flex flex-col gap-5">
                {inputFields.map((field, index) => (
                  <React.Fragment key={field.id}>
                    <div className="relative max-w-[100px] rounded-lg overflow-hidden bg-[#F7F7F7] group cursor-pointer">
                      <Picture
                        size={100}
                        fit="contain"
                        src={field.signature}
                        alt="official signature"
                      />
                      <div
                        style={{ backgroundColor: "rgba(0, 0, 0, 0.20)" }}
                        className="absolute inset-0 flex flex-col gap-2 items-center justify-center opacity-0 group-hover:opacity-100 duration-300"
                      >
                        <Picture src={ImageBlue} alt="image icon" size={20} />
                        <p
                          className="text-brand-9 text-xs font-normal"
                          onClick={() => changeSignatureImage(index)}
                        >
                          Change Image
                        </p>
                      </div>
                      <input
                        type="file"
                        id={`signature_input_${index}`}
                        name={`signature_${index}`}
                        accept="image/*"
                        onChange={handleSignatureChange(index)}
                        className="hidden"
                        ref={React.createRef()}
                      />
                    </div>
                    <div className="flex flex-col md:flex-row gap-5 justify-start md:justify-end md:items-end items-start">
                      <div className="flex-1">
                        <Select
                          id={`personal_title_qualification_${index}`}
                          options={titles}
                          defaultValue={state[index]?.title}
                          label="personal title / qualification"
                          inputContainerClassName="w-full bg-neutral-2"
                        />
                      </div>
                      <div className="flex-1">
                        <Input
                          id={`fullname_${index}`}
                          label="full name"
                          placeholder="Write Here"
                          className="w-full"
                          defaultValue={state[index]?.name}
                        />
                      </div>
                      <div className="flex flex-col sm:flex-row gap-3 items-end">
                        <Select
                          id={`real_estate_title_${index}`}
                          options={industryOptions}
                          defaultValue={state[index]?.professional_title}
                          label="real estate title"
                          inputContainerClassName="w-full bg-neutral-2"
                        />
                        {index !== 0 && (
                          <button
                            className="bg-brand-9 min-w-[50px] text-white text-xs font-normal py-2 px-3 rounded-lg max-h-[40px]"
                            onClick={() => removeInputField(field.id)}
                          >
                            Remove
                          </button>
                        )}
                      </div>
                    </div>
                  </React.Fragment>
                ))}
                <div className="flex items-end">
                  <button
                    className="text-xs font-normal py-2 px-3 w-full sm:w-auto text-brand-9 bg-white"
                    onClick={addInputField}
                    type="button"
                  >
                    Add More
                  </button>
                </div>
              </div>
            </div>
          </div>
          <SettingsUpdateButton
            submit
            action={hanleCreateSignature as any}
            loading={reqLoading}
            next={next}
          />
        </div>
      </AuthForm>
    </SettingsSection>
  )
}

export default SettingsSignature























==================

"use client";

import React, { useEffect, useState } from "react";

// Images
import { Check } from "lucide-react";
import DangerIcon from "@/public/icons/danger.svg";
import ImageBlue from "@/public/icons/image-blue.svg";
import SignatureImage from "@/public/accounting/signature.svg";

// Imports
import { industryOptions, titles } from "@/data";
import Input from "@/components/Form/Input/input";
import Picture from "@/components/Picture/picture";
import Select from "@/components/Form/Select/select";
import { useImageUploader } from "@/hooks/useImageUploader";
import SettingsSection from "@/components/Settings/settings-section";

import {
  SettingsSectionTitle,
  SettingsUpdateButton,
} from "@/components/Settings/settings-components";
import { usePersonalInfoStore } from "@/store/personal-info-store";
import { toast } from "sonner";
import { AuthForm } from "@/components/Auth/auth-components";
import { createSignatureProfiles, FormState } from "@/app/(nav)/settings/security/data";
import useFetch from "@/hooks/useFetch";
import useRefetchOnEvent from "@/hooks/useRefetchOnEvent";
import { SignaturePageData, transformSignature } from "@/app/(nav)/settings/data";

const SettingsSignature = () => {
  const [state, setState] = useState<SignaturePageData[]>([]);
  const { preview, inputFileRef, handleImageChange } = useImageUploader();
  const {
    data: apiData,
    loading,
    silentLoading,
    isNetworkError,
    error,
    refetch,
  } = useFetch<any>("/company-signatures");
  useRefetchOnEvent("refetchSignatures", () => refetch({ silent: true }));

  useEffect(() => {
    if (apiData) {
      setState(transformSignature(apiData));
    }
  }, [apiData]);

  console.log("signature", state)

  const [inputFields, setInputFields] = useState(() => {
    if (typeof window !== "undefined") {
      return [
        {
          id: Date.now(),
          signature: SignatureImage,
          signatureFile: new File([], ""), // Create File only on the client
        },
      ];
    }
    return [];
  });

  const [reqLoading, setReqLoading] = useState(false);
  const [next, setNext] = useState(false);
  const changeImage = () => {
    inputFileRef.current?.click();
  };

  const addInputField = () => {
    setInputFields([
      ...inputFields,
      { id: Date.now(), signature: SignatureImage, signatureFile: new File([], "") },
    ]);
  };

  const removeInputField = (id: number) => {
    const updatedFields = inputFields.filter((field) => field.id !== id);
    setInputFields(updatedFields);
    console.log("Input Fields after removing:", updatedFields);
  };

  const changeSignatureImage = (index: number) => {
    document.getElementById(`signature_input_${index}`)?.click();
  };

  const handleSignatureChange =
    (index: number) => (e: React.ChangeEvent<HTMLInputElement>) => {
      if (typeof window === "undefined" || !e.target.files || !e.target.files[0]) {
        return;
      }
      if (e.target.files && e.target.files[0]) {
        const newSignature = URL.createObjectURL(e.target.files[0]);
        const newFile = e.target.files[0];
        setInputFields(
          inputFields.map((inputField) =>
            inputField.id === inputFields[index].id
              ? { ...inputField, signature: newSignature, signatureFile: newFile }
              : inputField
          )
        );
      }
    };

  const hanleCreateSignature = async (data: FormData) => {
    const formData = new FormData();

    inputFields.forEach((field, index) => {
      formData.append(`name[${index}]`, data.get(`fullname_${index}`) as string);
      formData.append(`title[${index}]`, data.get(`personal_title_qualification_${index}`) as string);
      formData.append(`professional_title[${index}]`, data.get(`real_estate_title_${index}`) as string);
      formData.append(`signature[${index}]`, field.signatureFile); // Binary file
    });

    console.log("Payload:", Object.fromEntries(formData));

    try {
      setReqLoading(true);
      const res = await createSignatureProfiles(formData);
      if (res) {
        toast.success("Signature created successfully");
        setNext(true);
        window.dispatchEvent(new Event("fetch-profile"));
      }
    } catch (error) {
      toast.error("Error creating signature");
    } finally {
      setReqLoading(false);
    }
  };

  return (
    <SettingsSection title="Authorized Signature">
      <AuthForm onFormSubmit={hanleCreateSignature} returnType="form-data">
        <div className="custom-flex-col gap-8">
          <div className="custom-flex-col gap-6">
            <SettingsSectionTitle
              title=""
              desc="This signature is affixed to every document requiring authorization. Please sign on a plain white paper and take a photo for uploading. If possible, remove the background picture of the signature before uploading for a cleaner appearance."
            />
            <div className="custom-flex-col gap-[18px]">
              <div className="flex flex-col gap-5">
                {state.length > 0 &&
                  state.map((s, index) => (
                    <React.Fragment key={s.id}>
                      <div className="relative max-w-[100px] rounded-lg overflow-hidden bg-[#F7F7F7] group cursor-pointer">
                        <Picture
                          size={100}
                          fit="contain"
                          src={s.signature_image}
                          alt="official signature"
                        />
                      </div>
                      <div className="flex flex-col md:flex-row gap-5 justify-start md:justify-end md:items-end items-start">
                        <div className="flex-1">
                          <Select
                            id={`personal_title_qualification_${index}`}
                            options={titles}
                            defaultValue={s.title}
                            label="personal title / qualification"
                            inputContainerClassName="w-full bg-neutral-2"
                          />
                        </div>
                        <div className="flex-1">
                          <Input
                            id={`fullname_${index}`}
                            label="full name"
                            placeholder="Write Here"
                            className="w-full"
                            defaultValue={s.name}
                            disabled
                          />
                        </div>
                        <div className="flex flex-col sm:flex-row gap-3 items-end">
                          <Select
                            id={`real_estate_title_${index}`}
                            options={industryOptions}
                            defaultValue={s.professional_title}
                            label="real estate title"
                            disabled
                            inputContainerClassName="w-full bg-neutral-2"
                          />
                          <button
                            type="button"
                            className="bg-brand-9 min-w-[50px] text-white text-xs font-normal py-2 px-3 rounded-lg max-h-[40px]"
                          // onClick={() => removeInputField(field.id)}
                          >
                            delete
                          </button>
                        </div>
                      </div>
                    </React.Fragment>
                  ))}
              </div>
             {state.length <= 5 && <div className="flex flex-col gap-5">
                {inputFields.map((field, index) => (
                  <React.Fragment key={field.id}>
                    <div className="relative max-w-[100px] rounded-lg overflow-hidden bg-[#F7F7F7] group cursor-pointer">
                      <Picture
                        size={100}
                        fit="contain"
                        src={field.signature}
                        alt="official signature"
                      />
                      <div
                        style={{ backgroundColor: "rgba(0, 0, 0, 0.20)" }}
                        className="absolute inset-0 flex flex-col gap-2 items-center justify-center opacity-0 group-hover:opacity-100 duration-300"
                      >
                        <Picture src={ImageBlue} alt="image icon" size={20} />
                        <p
                          className="text-brand-9 text-xs font-normal"
                          onClick={() => changeSignatureImage(index)}
                        >
                          Change Image
                        </p>
                      </div>
                      <input
                        type="file"
                        id={`signature_input_${index}`}
                        name={`signature_${index}`}
                        accept="image/*"
                        onChange={handleSignatureChange(index)}
                        className="hidden"
                        ref={React.createRef()}
                      />
                    </div>
                    <div className="flex flex-col md:flex-row gap-5 justify-start md:justify-end md:items-end items-start">
                      <div className="flex-1">
                        <Select
                          id={`personal_title_qualification_${index}`}
                          options={titles}
                          // defaultValue={state[index]?.title}
                          label="personal title / qualification"
                          inputContainerClassName="w-full bg-neutral-2"
                        />
                      </div>
                      <div className="flex-1">
                        <Input
                          id={`fullname_${index}`}
                          label="full name"
                          placeholder="Write Here"
                          className="w-full"
                        // defaultValue={state[index]?.name}
                        />
                      </div>
                      <div className="flex flex-col sm:flex-row gap-3 items-end">
                        <Select
                          id={`real_estate_title_${index}`}
                          options={industryOptions}
                          // defaultValue={state[index]?.professional_title}
                          label="real estate title"
                          inputContainerClassName="w-full bg-neutral-2"
                        />
                        {index !== 0 && (
                          <button
                            className="bg-brand-9 min-w-[50px] text-white text-xs font-normal py-2 px-3 rounded-lg max-h-[40px]"
                            onClick={() => removeInputField(field.id)}
                          >
                            Remove
                          </button>
                        )}
                      </div>
                    </div>
                  </React.Fragment>
                ))}
               {state.length < 5 && inputFields.length < 5 &&  <div className="flex items-end">
                  <button
                    className="text-xs font-normal py-2 px-3 w-full sm:w-auto text-brand-9 bg-white"
                    onClick={addInputField}
                    type="button"
                  >
                    Add More
                  </button>
                </div>}
              </div>}
            </div>
          </div>
          <SettingsUpdateButton
            submit
            action={hanleCreateSignature as any}
            loading={reqLoading}
            next={next}
          />
        </div>
      </AuthForm>
    </SettingsSection>
  )
}

export default SettingsSignature





/////SIGNATURE LAST =======================
// "use client";

// import React, { useEffect, useState } from "react";

// // Images
// import { Check } from "lucide-react";
// import DangerIcon from "@/public/icons/danger.svg";
// import ImageBlue from "@/public/icons/image-blue.svg";
// import SignatureImage from "@/public/accounting/signature.svg";

// // Imports
// import { industryOptions, titles } from "@/data";
// import Input from "@/components/Form/Input/input";
// import Picture from "@/components/Picture/picture";
// import Select from "@/components/Form/Select/select";
// import { useImageUploader } from "@/hooks/useImageUploader";
// import SettingsSection from "@/components/Settings/settings-section";

// import {
//   SettingsSectionTitle,
//   SettingsUpdateButton,
// } from "@/components/Settings/settings-components";
// import { usePersonalInfoStore } from "@/store/personal-info-store";
// import { toast } from "sonner";
// import { AuthForm } from "@/components/Auth/auth-components";
// import { createSignatureProfiles, FormState } from "@/app/(nav)/settings/security/data";
// import useFetch from "@/hooks/useFetch";
// import useRefetchOnEvent from "@/hooks/useRefetchOnEvent";
// import { SignaturePageData, transformSignature } from "@/app/(nav)/settings/data";
// import { empty } from "@/app/config";


// const SettingsSignature = () => {
//   const [state, setState] = useState<SignaturePageData[]>([]);
//   const { preview, inputFileRef, handleImageChange } = useImageUploader();
//   const {
//     data: apiData,
//     loading,
//     silentLoading,
//     isNetworkError,
//     error,
//     refetch,
//   } = useFetch<any>("/company-signatures");
//   useRefetchOnEvent("refetchSignatures", () => refetch({ silent: true }));

//   useEffect(() => {
//     // Assuming apiData is defined somewhere in your component
//     if (apiData) {
//       const transformedData = transformSignature(apiData);
//       setState(transformedData);

//       // Update inputFields based on new state
//       setInputFields(transformedData.length > 0 ? transformedData.map(signature => ({
//         id: signature.id,
//         signature: signature.signature_image || empty,
//         signatureFile: new File([], ""), // Create File only on the client
//         name: signature.name,
//         title: signature.title,
//         professional_title: signature.professional_title
//       })) : [{
//         id: Date.now(),
//         signature: empty,
//         signatureFile: new File([], ""),
//       }]);
//     }
//   }, [apiData]);


//   const [inputFields, setInputFields] = useState(() => {
//     if (typeof window !== "undefined") {
//       // Check if state is empty and use default values if so
//       if (state.length > 0) {
//         return state.map(signature => ({
//           id: Date.now(),
//           signature: signature.signature_image,
//           signatureFile: new File([], ""), // Create File only on the client
//           name: signature.name,
//           title: signature.title,
//           professional_title: signature.professional_title
//         }));
//       } else {
//         return [
//           {
//             id: Date.now(),
//             signature: empty,
//             signatureFile: new File([], ""),
//           },
//         ];
//       }
//     }
//     return [];
//   });

//   // console.log("INput fields", inputFields)


//   const [reqLoading, setReqLoading] = useState(false);
//   const [next, setNext] = useState(false);
//   const changeImage = () => {
//     inputFileRef.current?.click();
//   };

//   const addInputField = () => {
//     setInputFields([
//       ...inputFields,
//       { id: Date.now(), signature: empty, signatureFile: new File([], "") },
//     ]);
//   };

//   const removeInputField = (id: number) => {
//     const updatedFields = inputFields.filter((field) => field.id !== id);
//     setInputFields(updatedFields);
//     // console.log("Input Fields after removing:", updatedFields);
//   };

//   const changeSignatureImage = (index: number) => {
//     document.getElementById(`signature_input_${index}`)?.click();
//   };

//   const handleSignatureChange =
//     (index: number) => (e: React.ChangeEvent<HTMLInputElement>) => {
//       if (typeof window === "undefined" || !e.target.files || !e.target.files[0]) {
//         return;
//       }
//       if (e.target.files && e.target.files[0]) {
//         const newSignature = URL.createObjectURL(e.target.files[0]);
//         const newFile = e.target.files[0];
//         setInputFields(
//           inputFields.map((inputField) =>
//             inputField.id === inputFields[index].id
//               ? { ...inputField, signature: newSignature, signatureFile: newFile }
//               : inputField
//           )
//         );
//       }
//     };

//   const hanleCreateSignature = async (data: FormData) => {
//     const formData = new FormData();

//     inputFields.forEach((field, index) => {
//       formData.append(`name[${index}]`, data.get(`fullname_${index}`) as string);
//       formData.append(`title[${index}]`, data.get(`personal_title_qualification_${index}`) as string);
//       formData.append(`professional_title[${index}]`, data.get(`real_estate_title_${index}`) as string);
//       // formData.append(`signature[${index}]`, field.signatureFile); // Binary file

//       if (typeof field.signature === 'string') {
//         formData.append(`signature[${index}]`, field.signature); // Append the string directly
//       } else {
//         formData.append(`signature[${index}]`, field.signatureFile); // Append the file
//       }
//     });

//     console.log("Payload:", Object.fromEntries(formData));

//     try {
//       setReqLoading(true);
//       const res = await createSignatureProfiles(formData);
//       if (res) {
//         toast.success("Signature created successfully");
//         setNext(true);
//         window.dispatchEvent(new Event("refetchSignatures"));
//       }
//     } catch (error) {
//       toast.error("Error creating signature");
//     } finally {
//       setReqLoading(false);
//     }
//   };

//   return (
//     <SettingsSection title="Authorized Signature">
//       <AuthForm onFormSubmit={hanleCreateSignature} returnType="form-data">
//         <div className="custom-flex-col gap-8">
//           <div className="custom-flex-col gap-6">
//             <SettingsSectionTitle
//               title=""
//               desc="This signature is affixed to every document requiring authorization. Please sign on a plain white paper and take a photo for uploading. If possible, remove the background picture of the signature before uploading for a cleaner appearance."
//             />
//             <div className="custom-flex-col gap-[18px]">
//               <div className="flex flex-col gap-5">
//                 {inputFields.map((field, index) => (
//                   <React.Fragment key={field.id}>
//                     <div className="relative max-w-[100px] rounded-lg overflow-hidden bg-[#F7F7F7] group cursor-pointer">
//                       <Picture
//                         size={100}
//                         fit="contain"
//                         src={field.signature}
//                         alt="official signature"
//                       />
//                       <div
//                         style={{ backgroundColor: "rgba(0, 0, 0, 0.20)" }}
//                         onClick={() => changeSignatureImage(index)}
//                         className="absolute inset-0 flex flex-col gap-2 items-center justify-center opacity-0 group-hover:opacity-100 duration-300"
//                       >
//                         <Picture src={ImageBlue} alt="image icon" size={20} />
//                         <p
//                           className="text-brand-9 text-xs font-normal"
//                           // onClick={() => changeSignatureImage(index)}
//                         >
//                           Change Image
//                         </p>
//                       </div>
//                       <input
//                         type="file"
//                         id={`signature_input_${index}`}
//                         name={`signature_${index}`}
//                         accept="image/*"
//                         onChange={handleSignatureChange(index)}
//                         className="hidden"
//                         ref={React.createRef()}
//                       />
//                     </div>
//                     <div className="flex flex-col md:flex-row gap-5 justify-start md:justify-end md:items-end items-start">
//                       <div className="flex-1">
//                         <Select
//                           id={`personal_title_qualification_${index}`}
//                           options={titles}
//                           defaultValue={state[index]?.title}
//                           label="personal title / qualification"
//                           inputContainerClassName="w-full bg-neutral-2"
//                         />
//                       </div>
//                       <div className="flex-1">
//                         <Input
//                           id={`fullname_${index}`}
//                           label="full name"
//                           placeholder="Write Here"
//                           className="w-full"
//                           defaultValue={state[index]?.name}
//                         />
//                       </div>
//                       <div className="flex flex-col sm:flex-row gap-3 items-end">
//                         <Select
//                           id={`real_estate_title_${index}`}
//                           options={industryOptions}
//                           defaultValue={state[index]?.professional_title}
//                           label="real estate title"
//                           inputContainerClassName="w-full bg-neutral-2"
//                         />
//                         {index !== 0 && (
//                           <button
//                             className="bg-brand-9 min-w-[50px] text-white text-xs font-normal py-2 px-3 rounded-lg max-h-[40px]"
//                             onClick={() => removeInputField(field.id)}
//                           >
//                             Remove
//                           </button>
//                         )}
//                       </div>
//                     </div>
//                   </React.Fragment>
//                 ))}
//                 <div className="flex items-end">
//                   <button
//                     className="text-xs font-normal py-2 px-3 w-full sm:w-auto text-brand-9 bg-white"
//                     onClick={addInputField}
//                     type="button"
//                   >
//                     Add More
//                   </button>
//                 </div>
//               </div>
//             </div>
//           </div>
//           <SettingsUpdateButton
//             submit
//             action={hanleCreateSignature as any}
//             loading={reqLoading}
//             next={next}
//           />
//         </div>
//       </AuthForm>
//     </SettingsSection>
//   )
// }

// export default SettingsSignature




















///appearance
  const { selectedOptions, setSelectedOption } = useSettingsStore();
  const [reqLoading, setReqLoading] = useState(false);
  const [next, setNext] = useState(false);
  const [selectedTheme, setSelectedTheme] = useState<string | null>(
    appearance.theme
    // appearance.theme || selectedOptions.theme
  );
  const [selectedView, setSelectedView] = useState<string | null>(
    appearance.view
    // appearance.view || selectedOptions.view
  );
  const [selectedNavbar, setSelectedNavbar] = useState<string | null>(
    // appearance.navbar || selectedOptions.navbar
  );
  const [selectedMode, setSelectedMode] = useState<string | null>(
    appearance.mode || selectedOptions.mode
  );
  const [selectedFont, setSelectedFont] = useState<string | null>(
    appearance.font || selectedOptions.font
  );
  const [selectedColor, setSelectedColor] = useState<string | null>(
    primaryColor
  );









  ==============STAFF
         {/* {staff.map(({ id, label }) => (
              <div
                key={id}
                className='relative'
              >
                <Select
                  options={staffOptions}
                  // options={staffOption}
                  id={id}
                  label={label}
                  inputContainerClassName='bg-white'
                />
                <button
                  type='button'
                  aria-label='Remove Staff'
                  onClick={() => removeStaff(id)}
                  className='absolute top-0 right-0 w-[18px] h-[18px]'
                >
                  <DeleteIconX size={20} />
                </button>
              </div>
            ))}
            {staff.length < 3 && (
              <button
                type='button'
                onClick={addStaff}
                className='text-brand-9 text-xs md:text-sm font-normal md:self-end md:justify-self-start'
              >
                {`${staff.length > 0 ? 'Add more staff' : 'Add Staff'}`}
              </button>
            )} */}


















            ==============MessageUserPageTypes// Imports
import { usePersonalInfoStore } from "@/store/personal-info-store";
import Message from "./message";
import { MessagesProps } from "./types";

const Messages: React.FC<MessagesProps> = ({ day, messages }) => {
  const userId = usePersonalInfoStore((state) => state.user_id);
  return (
    <div className="custom-flex-col gap-8">
      <div className="flex justify-center sticky top-0">
        <p className="py-1 px-2 rounded-[4px] bg-neutral-2 dark:bg-darkText-primary text-text-quaternary dark:text-white text-[10px] font-normal capitalize">
          {day}
        </p>
      </div>
      <div className="custom-flex-col gap-4">
        {messages?.map((m) => (
          <>
            <Message
              key={m.time}
              type={m.type}
              time={m.time}
              text={m.text}
            />
          </>
        ))}
        {/* <Message
          type="to user"
          time="8:32am"
          text="Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec vitae ullamcorper urna. "
        />
        <Message
          type="from user"
          time="8:32am"
          text="Nunc quis sagittis justo, ac fringilla nulla. Quisque eu risus ex. Quisque cursus quis mauris vel efficitur. Donec at bibendum leo, nec consequat mauris. Duis id risus nulla."
        />
        <Message
          type="to user"
          time="8:32am"
          text="Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec vitae ullamcorper urna. "
        /> */}
      </div>
    </div>
  );
};

export default Messages;
















===========CHAT INTEGARET

"use client";
import { useEffect, useState } from "react";
import { useParams, useRouter } from "next/navigation";
import { useChatStore } from "@/store/message";
import { transformMessages } from "../data";
import Picture from "@/components/Picture/picture";
import Messages from "@/components/Message/messages";
import { empty } from "@/app/config";
import { UsersProps } from "../types";
import useGetConversation from "@/hooks/getConversation";

const Chat = () => {
  const router = useRouter();
  const { data, setChatData } = useChatStore();
  const usersData = useChatStore((state) => state?.data?.users);
  const { id } = useParams<{ id: string }>();
  const users = usersData?.users || [];
  const userId = Number(id);
  const store_messages = useChatStore((state) => state?.data?.conversations);
  const [conversations, setConversations] = useState<any[]>([]);

  // Clear local conversation state when conversation id changes.
  useEffect(() => {
    setConversations([]);
  }, [id]);

  // Fetch the conversation messages (this hook uses your fetch-event-source logic)
  useGetConversation(`${id}`);

  // Transform and set sorted conversations whenever the store updates.
  useEffect(() => {
    if (store_messages) {
      const transformedMessages = transformMessages(store_messages);
      // Instead of accumulating new messages, simply override with the full sorted list.
      setConversations(transformedMessages);
    }
  }, [store_messages]);

  // If user not found, redirect to messages page
  const user = users.find((user: UsersProps) => Number(user.id) === userId);
  if (!user) {
    router.replace("/messages");
    return null;
  }

  return (
    <>
      <div className="py-4 px-6 bg-neutral-2 dark:bg-black">
        <div className="flex items-center gap-3">
          <button onClick={() => router.push("/messages")}>
            <Picture src="/icons/chevron-left.svg" alt="back" size={20} />
          </button>
          <button className="flex items-center gap-4 text-left">
            <Picture
              src={user?.imageUrl || empty}
              alt="profile picture"
              containerClassName="custom-secondary-bg rounded-full"
              size={32}
              rounded
              status
            />
            <div className="custom-flex-col">
              <p className="text-text-primary dark:text-white text-base font-medium capitalize">
                {user?.name}
              </p>
              <p className="text-text-disabled dark:text-darkText-2 text-[10px] font-normal">
                Tap here for contact info
              </p>
            </div>
          </button>
        </div>
      </div>
      <div className="py-5 px-6 flex-1 overflow-auto custom-round-scrollbar bg-white dark:bg-black custom-flex-col gap-8">
        {conversations.length > 0 &&
          conversations.map((m) => (
            <Messages key={m.id} day={m.day} messages={m.details} userId={user.id} />
          ))}
      </div>
    </>
  );
};

export default Chat;