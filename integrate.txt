 const handleClickSend = async () => {
    if (activeStep === "send funds") {
      if (!description) {
        toast.warning("Please enter a description");
        return;
      }
      if (!(amount > 0)) {
        toast.warning("Please enter an amount");
        return;
      }
      if (branch && amount > Number(balance.my_balance)) {
        toast.warning("Insufficient balance");
        return;
      }
      setActiveStep("confirm pin");
    } else {
      if (pin.length !== 4) {
        toast.warning("Please enter your PIN");
        return;
      }
      setLoading(true);
      const action = branch
        ? branchFundWallet({ wallet_id, amount, pin, description })
        : transferFunds(wallet_id, amount, description, pin);
      const status = await action;
      if (status) {
        setIsOpen(false);
        if (!isAlreadyBeneficiary && saveAsBeneficiary && my_wallet_id) {
          await addBeneficiary(wallet_id, my_wallet_id, {
            noToast: true,
          });
        }
        window.dispatchEvent(new Event("refetch-wallet"));
      }
      setLoading(false);
    }
  };










 const handleUpdateProfile = async (data: Record<string, string>) => {
    const paylo
    ad = {
      name: data.fullname,
      title: data.personal_title,
      // estate_title: data.real_estate_title,
      // email: data.email,
      // phone_number: data.phone_number,
      // gender: data.gender,
    };
    // cleanPhoneNumber(payload);
    // if (!payload.phone_number) {
    //   payload.phone_number = "";
    // }

    try {
      setReqLoading(true);
      const status = await updateUserProfile(objectToFormData(payload));
      if (status) {
        setNext(true);
        window.dispatchEvent(new Event("fetch-profile"));
      }
    } catch (error) {
      toast.error("Error updating profile");
    } finally {
      setReqLoading(false);
      setNext(false);
    }
  };















    // const handleSubmit = async(data: Record<string, string>) => {
  //   if (isForgetPin) {
  //     setIsForgetPin(false); // Reset `isForgetPin`
  //     setIsOpen(true); 
  //     try{
  //       // const response = await 
  //       console.log("Goin to API", data)
  //     } catch (error) {
  //       console.error(error);
  //     }
  //   } else {
  //     setIsOpen(true); // Open the modal directly
  //     try{
  //       // const response = await 
  //       console.log("Goin to API", data)
  //     } catch (error) {
  //       console.error(error);
  //     }
  //   }
  // };




















  "use client";

import React, { useEffect, useRef, useState } from "react";

// Types
import type { DefaultSettingsModalProps } from "../types";

// Imports
import PinField from "react-pin-field";
import Button from "@/components/Form/Button/button";
import WalletModalPreset from "@/components/Wallet/wallet-modal-preset";
import Input from "@/components/Form/Input/input";
import { AuthForm } from "@/components/Auth/auth-components";
import { useWalletStore } from "@/store/wallet-store";
import { WalletDataResponse } from "@/app/(nav)/wallet/data";
import useFetch from "@/hooks/useFetch";
import { toast } from "sonner";
import { ForgetWalletPinPassword } from "@/app/(nav)/settings/profile/data";

const ForgetWalletModal: React.FC<DefaultSettingsModalProps> = ({
  changeStep,
}) => {
  const pinFieldRef = useRef<HTMLInputElement[] | null>(null);
  const [loading, setLoading] = useState(false)
  const setWalletStore = useWalletStore((s) => s.setWalletStore)
  const { data, error, refetch } =
  useFetch<WalletDataResponse>("/wallets/dashboard");
  
  const walletId = data?.balance.wallet_id;
  setWalletStore("walletId", walletId as string);

  useEffect(() => {
    if (pinFieldRef.current && pinFieldRef.current.length > 0) {
      pinFieldRef.current[0].focus();
    }
  }, []);

  const hanldeForgetPassword = async(data: Record<string, string>)=>{
    try{
      setLoading(true)
      const payload = {
        wallet_id: walletId as string,
        password: data.password
      }
      console.log("payload", payload)
      const res = await ForgetWalletPinPassword(payload);
      if(res){
        toast.success("Wallet pin changed successfully")
        changeStep(3);
      }
    } catch (err){
        toast.error("Failed to forget wallet password")
    } finally{
      setLoading(false)
    }
  }

  return (
    <WalletModalPreset
      title="Forget Wallet PIN"
      style={{ width: 390, borderRadius: 20 }}
    >
    <AuthForm onFormSubmit={hanldeForgetPassword} autoComplete="off">
      <div className="custom-flex-col gap-20">
        <div className="custom-flex-col gap-10">
          <p className="text-text-tertiary text-center text-sm font-medium">
          Please enter your password to proceed with resetting your wallet PIN securely. This ensures your account remains protected and only authorized changes are made.
          </p>
          <div className="flex gap-6 justify-center">
           <Input
            id="password"
            label="Enter Password"
            type="password"
            inputClassName="w-full"
            className="w-full"
           />
          </div>
        </div>
        <Button
          size="sm_medium"
          type="submit"
          className="py-2 px-8"
        >
          {loading ? "Please wait..." : "Proceed"}
        </Button>
      </div>
      </AuthForm>
    </WalletModalPreset>
  );
};

export default ForgetWalletModal;


















                {/* <Select
                  options={landlordOptions}
                  id="land_lord_id"
                  label="Landlord"
                  inputContainerClassName="bg-white"
                  resetKey={resetKey}
                  defaultValue={
                    editMode && propertyDetails?.land_lord_id
                      ? landlordOptions.find(
                          (landlord) => landlord.value === propertyDetails.land_lord_id
                        )
                      : undefined
                  }
                  hiddenInputClassName="property-form-input"
                  placeholder={
                    landlordsLoading
                      ? "Loading landlords..."
                      : landlordsError
                      ? "Error loading landlords"
                      : "Select landlord"
                  }
                  error={landlordsError}
                /> */}




=================FILTER MODAL ==================
import { useState } from "react";
import { ModalTrigger } from "@/components/Modal/modal";
import { ChevronRight, ChevronLeft } from "lucide-react";
import DateInput from "@/components/Form/DateInput/date-input";
import dayjs, { Dayjs } from "dayjs";
import Button from "@/components/Form/Button/button";
import { FilterModalProps, FilterOptionMenu } from "./types";
import { CancelIcon, CheckboxCheckedIcon } from "@/public/icons/icons";
import { useModal } from "@/components/Modal/modal";
import Checkbox from "@/components/Form/Checkbox/checkbox";

const FilterModal: React.FC<FilterModalProps> = ({
  filterOptions,
  filterOptionsMenu,
  handleFilterApply,
  filterTitle = "Filters by",
  isDateTrue,
  dateLabel = "Date",
  appliedFilters,
}) => {
  const { setIsOpen } = useModal();
  const isRadio =
    typeof filterOptions === "object" &&
    !Array.isArray(filterOptions) &&
    filterOptions.radio;

  const [selectedStartDate, setSelectedStartDate] = useState<string | null>(
    appliedFilters?.startDate || null
  );
  const [selectedEndDate, setSelectedEndDate] = useState<string | null>(
    appliedFilters?.endDate || null
  );

  const handleDateChange = (type: "start" | "end", date?: Dayjs | null) => {
    if (type === "start") {
      setSelectedStartDate(date && date.isValid() ? date.toISOString() : null);
    } else if (type === "end") {
      setSelectedEndDate(date && date.isValid() ? date.toISOString() : null);
    }
  };

  // Apply filters and close modal
  const handleApplyFilter = () => {
    const selectedOptions = [...selectedFilters];
    const selectedMenuOptions = { ...selectedFilterMenus };
    const filtersToApply = {
      options: selectedOptions,
      menuOptions: selectedMenuOptions,
      startDate: selectedStartDate,
      endDate: selectedEndDate,
    };
    handleFilterApply(filtersToApply);
    setIsOpen(false);
  };

  const [searchQuery, setSearchQuery] = useState("");
  const [selectedFilters, setSelectedFilters] = useState<string[]>(() => {
    if (appliedFilters?.options) return appliedFilters.options;
    
    // Find radio group with default checked option
    const defaultRadioValue = filterOptionsMenu?.find(menu => menu.radio)
      ?.value.find(option => option.isChecked)?.value;
    
    if (defaultRadioValue) {
      return [String(defaultRadioValue)];
    }
    
    return [];
  });
  const [selectedFilterMenus, setSelectedFilterMenus] = useState<Record<string, string[]>>(() => {
    if (appliedFilters?.menuOptions) return appliedFilters.menuOptions;
    
    // Initialize radio groups with default values
    const initialMenus: Record<string, string[]> = {};
    filterOptionsMenu?.forEach(menu => {
      if (menu.radio) {
        const defaultValue = menu.value.find(option => option.isChecked)?.value;
        if (defaultValue) {
          initialMenus[menu.label] = [String(defaultValue)];
        }
      }
    });
    
    return initialMenus;
  });
  const [view, setView] = useState<"default" | "date" | "menu">("default");
  const commonCheckboxClasses =
    "flex-row-reverse w-full justify-between bg-[#F5F5F5] dark:bg-[#3C3D37] py-2 px-4 capitalize";
  const commonLabelClasses =
    "text-text-secondary dark:text-darkText-1 font-medium flex items-center justify-between py-2 px-4 bg-[#F5F5F5] dark:bg-[#3C3D37] capitalize cursor-pointer";
  const [activeOptionMenu, setActiveOptionMenu] =
    useState<FilterOptionMenu | null>(null);

  const handleOptionMenuClick = (option: FilterOptionMenu) => {
    setSearchQuery("");
    setActiveOptionMenu(option);
    setView("menu");
  };

  const handleOptionClick = (value: string) => {
    setSelectedFilters((prev) =>
      prev.includes(value) ? prev.filter((x) => x !== value) : [...prev, value]
    );
  };

  const handleOptionMenuItemClick = (
    menuLabel: string,
    value: string,
    isRadio?: boolean
  ) => {
    setSelectedFilterMenus((prev) => {
      const currentSelections = prev[menuLabel] || [];
      if (isRadio) {
        return {
          ...prev,
          [menuLabel]: currentSelections.includes(value) ? [] : [value],
        };
      } else {
        const newSelections = currentSelections.includes(value)
          ? currentSelections.filter((v) => v !== value)
          : [...currentSelections, value];
        return { ...prev, [menuLabel]: newSelections };
      }
    });
  };

  const filteredOptions = activeOptionMenu?.value.filter((option) =>
    option.label.toLowerCase().includes(searchQuery.toLowerCase())
  );

  return (
    <div className="w-[400px] max-h-[90vh] overflow-y-auto rounded-[20px] bg-white dark:bg-darkText-primary p-[20px] custom-flex-col">
      <div className="flex items-center justify-between border-b border-solid border-gray-300 ">
        <div className="flex items-center gap-1">
          {view !== "default" && (
            <button
              onClick={() => {
                setView("default");
                setActiveOptionMenu(null);
              }}
            >
              <ChevronLeft />
            </button>
          )}
          <h2 className="text-lg font-bold text-primary-navy dark:text-white">
            {view === "default"
              ? filterTitle
              : view === "date"
                ? dateLabel
                : activeOptionMenu?.label}
          </h2>
        </div>
        {view === "default" && (
          <ModalTrigger close className="p-2">
            <CancelIcon />
          </ModalTrigger>
        )}
      </div>
      <div className="space-y-2 my-4">
        {view === "default" ? (
          <>
            {isDateTrue && (
              <div
                role="button"
                className={commonLabelClasses}
                onClick={() => setView("date")}
              >
                <span>{dateLabel}</span>
                {selectedStartDate || selectedEndDate ? (
                  <CheckboxCheckedIcon />
                ) : (
                  <ChevronRight className="text-[#344054]" />
                )}
              </div>
            )}
            {filterOptionsMenu?.map((option, i) => (
              <div
                key={i}
                role="button"
                className={commonLabelClasses}
                onClick={() => handleOptionMenuClick(option)}
              >
                <span>{option.label}</span>
                {selectedFilterMenus[option.label] &&
                  selectedFilterMenus[option.label].length > 0 ? (
                  <CheckboxCheckedIcon />
                ) : (
                  <ChevronRight className="text-[#344054]" />
                )}
                {option.isChecked && (
                  <Checkbox
                    checked={selectedFilters.includes(String(option.value)) || option.isChecked}
                    onChange={() => handleOptionClick(String(option.value))}
                  />
                )}
              </div>
            ))}
            {!isRadio &&
              Array.isArray(filterOptions) &&
              filterOptions.map((option, i) => (
                <Checkbox
                  key={i}
                  className={commonCheckboxClasses}
                  checked={selectedFilters.includes(option.value)}
                  onChange={() => handleOptionClick(option.value)}
                >
                  {option.label}
                </Checkbox>
              ))}
            {isRadio &&
              Array.isArray(filterOptions?.value) &&
              filterOptions.value.map((option, i) => (
                <Checkbox 
                  key={i}
                  radio={true}
                  className={commonCheckboxClasses}
                  checked={selectedFilters.includes(option.value)}
                  onChange={() => {
                    setSelectedFilters([option.value]);
                  }}
                >
                  {option.label}
                </Checkbox>
              ))}
           </>
        ) : view === "date" ? (
          <>
            <DateInput
              label="From"
              id="date_from"
              value={selectedStartDate ? dayjs(selectedStartDate) : undefined}
              onChange={(date) => handleDateChange("start", date)}
              disableFuture
            />
            <DateInput
              label="To"
              id="date_to"
              value={selectedEndDate ? dayjs(selectedEndDate) : undefined}
              onChange={(date) => handleDateChange("end", date)}
              disableFuture
            />
          </>
        ) : (
          <>
            <input
              type="text"
              className="w-full border p-2"
              placeholder="Search"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
            />
            <div className="max-h-[200px] overflow-y-auto pr-1 custom-round-scrollbar space-y-2 my-2">
              {filteredOptions?.map((option, i) => (
                <Checkbox
                  key={i}
                  radio={activeOptionMenu?.radio}
                  className={commonCheckboxClasses}
                  checked={selectedFilterMenus[
                    activeOptionMenu!.label
                  ]?.includes(option.value)}
                  onChange={() =>
                    handleOptionMenuItemClick(
                      activeOptionMenu!.label,
                      option.value,
                      activeOptionMenu!.radio
                    )
                  }
                >
                  {option.label}
                </Checkbox>
              ))}
            </div>
          </>
        )}
      </div>
      <Button
        className="w-full py-2 rounded-lg mt-4"
        size="base_medium"
        onClick={() => {
          if (view === "default") {
            handleApplyFilter();
          } else {
            setView("default");
          }
        }}
      >
        {view === "default" ? "Apply Filters" : "OK"}
      </Button>
    </div>
  );
};

export default FilterModal;
